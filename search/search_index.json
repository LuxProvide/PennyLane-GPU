{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to PennyLane with GPUs","text":""},{"location":"#about-this-course","title":"About this course","text":"<p>This course has been developed by the Supercomputing Application Services group at LuxProvide. </p>"},{"location":"pennylane_final/","title":"Quantum Computing using PennyLane library","text":"<p>This presentation is designed to introduce quantum computing using PennyLane, a versatile quantum machine learning library, with a focus on GPU capabilities. The presentation is structured using simple language, interactive examples, and hands-on coding in Jupyter Notebook. We will explore how PennyLane can leverage GPUs for quantum computing tasks and provide real-world examples.</p> <p>PennyLane offers impressive versatility through its support for multiple quantum computing backends:</p> <ul> <li><p>Qiskit: IBM's quantum computing framework</p> </li> <li><p>Cirq: Google's quantum computing library</p> </li> <li><p>Amazon Braket: Amazon's quantum computing service</p> </li> <li><p>Microsoft Azure Quantum: Microsoft's cloud quantum computing platform</p> </li> <li><p>Rigetti Forest: Rigetti's quantum programming toolkit</p> </li> <li><p>ProjectQ: ETH Zurich's open-source quantum computing framework</p> </li> </ul> <p>This wide range of supported backends allows users to develop quantum algorithms that can run on various quantum hardware and simulators without changing their core code.</p> <p>PennyLane places a strong emphasis on GPU compatibility to accelerate quantum simulations and hybrid quantum-classical computations. It leverages GPU acceleration through:</p> <ul> <li>Integration with JAX, a high-performance numerical computing library</li> <li>Support for NVIDIA cuQuantum SDK for GPU-accelerated quantum circuit simulations</li> <li>Compatibility with PyTorch and TensorFlow's GPU operations for classical processing</li> </ul> <p>This GPU focus enables researchers and developers to run large-scale quantum simulations and optimize complex quantum-classical models more efficiently, significantly reducing computation time for quantum machine learning tasks.</p> In\u00a0[1]: Copied! <pre>%%bash\nKERNEL=\"$HOME/.local/share/jupyter/kernels/pennylane\"\nmkdir -p $KERNEL\nPRELOAD=\"$KERNEL/start.sh\"\nJSON=\"$KERNEL/kernel.json\"\ncat &lt;&lt; 'EOF' &gt; $JSON\n{\n \"argv\": [\n  \"{resource_dir}/start.sh\",\n  \"python\",\n  \"-m\",\n  \"ipykernel_launcher\",\n  \"-f\",\n  \"{connection_file}\"\n ],\n \"display_name\": \"PennyLane\",\n \"language\": \"python\",\n \"metadata\": {\n  \"debugger\": true\n }\n}\nEOF\n\ncat &lt;&lt; 'EOF' &gt; $PRELOAD\n#!/bin/bash\nmodule load matplotlib/3.7.2-gfbf-2023a  Seaborn/0.13.2-gfbf-2023a\nmodule load PennyLane-bundle/0.37.0-foss-2023a-CUDA-12.2.0\nmodule load TensorFlow/2.15.1-foss-2023a-CUDA-12.1.1\nmodule load jaxopt/0.8.3-gfbf-2023a-CUDA-12.1.1\nexec \"$@\"\nEOF\n\nchmod u+x $PRELOAD\n</pre> %%bash KERNEL=\"$HOME/.local/share/jupyter/kernels/pennylane\" mkdir -p $KERNEL PRELOAD=\"$KERNEL/start.sh\" JSON=\"$KERNEL/kernel.json\" cat &lt;&lt; 'EOF' &gt; $JSON {  \"argv\": [   \"{resource_dir}/start.sh\",   \"python\",   \"-m\",   \"ipykernel_launcher\",   \"-f\",   \"{connection_file}\"  ],  \"display_name\": \"PennyLane\",  \"language\": \"python\",  \"metadata\": {   \"debugger\": true  } } EOF  cat &lt;&lt; 'EOF' &gt; $PRELOAD #!/bin/bash module load matplotlib/3.7.2-gfbf-2023a  Seaborn/0.13.2-gfbf-2023a module load PennyLane-bundle/0.37.0-foss-2023a-CUDA-12.2.0 module load TensorFlow/2.15.1-foss-2023a-CUDA-12.1.1 module load jaxopt/0.8.3-gfbf-2023a-CUDA-12.1.1 exec \"$@\" EOF  chmod u+x $PRELOAD In\u00a0[2]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[3]: Copied! <pre># This cell is added by sphinx-gallery\n# It can be customized to whatever you like\n%matplotlib inline\n</pre> # This cell is added by sphinx-gallery # It can be customized to whatever you like %matplotlib inline In\u00a0[4]: Copied! <pre>import pennylane as qml\nfrom pennylane import numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n</pre> import pennylane as qml from pennylane import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D In\u00a0[5]: Copied! <pre># Create a default qubit simulator with 2 qubits\ndev = qml.device('default.qubit', wires=2)\n</pre> # Create a default qubit simulator with 2 qubits dev = qml.device('default.qubit', wires=2) <p>For all devices, <code>device</code> accepts the following arguments:</p> <ul> <li><code>name</code>: the name of the device to be loaded</li> <li><code>wires</code>: the number of subsystems (qubits in qubit model) to initialize the device with. It is also possible to label the wires, for example <code>wires=['q1', 'q2']</code></li> </ul> <p>Some devices also accepts <code>shots</code> option for setting the number of circuit evaluations/random samples used to estimate expectation values of observables.</p> In\u00a0[7]: Copied! <pre># shots and qubits labels example\ndev_unique_wires = qml.device('default.qubit', wires=['q1', 'q2'], shots = [10, 1000])\n</pre> # shots and qubits labels example dev_unique_wires = qml.device('default.qubit', wires=['q1', 'q2'], shots = [10, 1000]) In\u00a0[8]: Copied! <pre>def quantum_circuit():\n    qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.\n    return qml.state()          # Return the final quantum state\n</pre> def quantum_circuit():     qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.     return qml.state()          # Return the final quantum state <p>This is a simple circuit, applying a PauliX gate to the first Qubit, it flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa. Notice that the function <code>quantum_circuit()</code> is constructed as if it were any other Python function; it accepts a positional argument <code>params</code>, which may be a list, tuple, or array, and uses the individual elements for gate parameters.</p> <p>However, quantum functions are a restricted subset of Python functions. For a Python function to also be a valid quantum function, there are some important restrictions:</p> <ul> <li><p>Quantum functions must contain quantum operations, one operation per line, in the order in which they are to be applied.</p> <p>In addition, we must always specify the subsystem the operation applies to, by passing the <code>wires</code> argument; this may be a list or an integer, depending on how many wires the operation acts on.</p> </li> <li><p>Quantum functions must return either a single or a tuple of measured observables.</p> <p>As a result, the quantum function always returns a classical quantity, allowing the QNode to interface with other classical functions (and also other QNodes).</p> </li> </ul> <p>NOTE: Certain devices may only support a subset of the available PennyLane operations/observables, or may even provide additional operations/observables. Please consult the documentation for the plugin/device for more details.</p> <p>Once we have written the quantum function, we convert it into a <code>QNode</code> running on device <code>dev</code> by applying the <code>qnode</code> decorator. directly above the function definition:</p> In\u00a0[9]: Copied! <pre>@qml.qnode(dev)\ndef quantum_circuit():\n    qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.\n    return qml.state()          # Return the final quantum statell\n</pre> @qml.qnode(dev) def quantum_circuit():     qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.     return qml.state()          # Return the final quantum statell <p>Thus, our <code>quantum_circuit()</code> quantum function is now a QNode, which will run on device <code>dev</code> every time it is evaluated.</p> <p>To evaluate, we simply call the function :</p> In\u00a0[10]: Copied! <pre>result = quantum_circuit()\nresult\n</pre> result = quantum_circuit() result Out[10]: <pre>tensor([0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], requires_grad=True)</pre> <p>We can even print the circuit:</p> In\u00a0[11]: Copied! <pre>print(qml.draw(quantum_circuit)())\n</pre> print(qml.draw(quantum_circuit)()) <pre>0: \u2500\u2500X\u2500\u2524  State\n</pre> <p>A nicer circuit draw with matplotlib</p> In\u00a0[12]: Copied! <pre>qml.drawer.use_style(\"black_white\")\nfig, ax = qml.draw_mpl(quantum_circuit)()\nplt.show()\n</pre> qml.drawer.use_style(\"black_white\") fig, ax = qml.draw_mpl(quantum_circuit)() plt.show() <p>This quantum circuit diagram shows our first qubit system undergoing a simple PauliX rotation. It is measured afterwards.</p> In\u00a0[13]: Copied! <pre># Create a device with 2 qubits using the default qubit simulator\ndev = qml.device('default.qubit', wires=2)\n</pre> # Create a device with 2 qubits using the default qubit simulator dev = qml.device('default.qubit', wires=2) In\u00a0[14]: Copied! <pre>#import pennylane as qml\n#from pennylane import numpy as np\n#import matplotlib.pyplot as plt\n#from mpl_toolkits.mplot3d import Axes3D\n\n\n# Create a device with 2 qubits using the default qubit simulator\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef pauli_gates_circuit():\n    # Apply Pauli-X gate to the first qubit\n    qml.PauliX(wires=0)\n    # Apply Pauli-Y gate to the second qubit\n    qml.PauliY(wires=1)\n    # Apply Pauli-Z gate to the first qubit\n    qml.PauliZ(wires=0)\n    # Measure expectation values of Pauli-Z for both qubits\n    #return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n    return qml.state()\n\n# Run the circuit\nresults = pauli_gates_circuit()\nprint(\"Pauli Gates Circuit Output:\", results)\n</pre> #import pennylane as qml #from pennylane import numpy as np #import matplotlib.pyplot as plt #from mpl_toolkits.mplot3d import Axes3D   # Create a device with 2 qubits using the default qubit simulator dev = qml.device('default.qubit', wires=2)  @qml.qnode(dev) def pauli_gates_circuit():     # Apply Pauli-X gate to the first qubit     qml.PauliX(wires=0)     # Apply Pauli-Y gate to the second qubit     qml.PauliY(wires=1)     # Apply Pauli-Z gate to the first qubit     qml.PauliZ(wires=0)     # Measure expectation values of Pauli-Z for both qubits     #return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]     return qml.state()  # Run the circuit results = pauli_gates_circuit() print(\"Pauli Gates Circuit Output:\", results) <pre>Pauli Gates Circuit Output: [0.+0.j 0.+0.j 0.+0.j 0.-1.j]\n</pre> <p>Circuit representation:</p> In\u00a0[15]: Copied! <pre>qml.drawer.use_style(\"black_white\")\nfig, ax = qml.draw_mpl(pauli_gates_circuit)()\nplt.show()\n</pre> qml.drawer.use_style(\"black_white\") fig, ax = qml.draw_mpl(pauli_gates_circuit)() plt.show() In\u00a0[17]: Copied! <pre>@qml.qnode(dev)\ndef hadamard_gate_circuit():\n    # Apply Hadamard gate to the first qubit\n    qml.Hadamard(wires=0)\n    # Apply Hadamard gate to the second qubit\n    qml.Hadamard(wires=1)\n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Run the circuit\nprint(\"Hadamard Gate Circuit Output:\", hadamard_gate_circuit())\nfig, ax = qml.draw_mpl(hadamard_gate_circuit)()\nplt.show()\n</pre> @qml.qnode(dev) def hadamard_gate_circuit():     # Apply Hadamard gate to the first qubit     qml.Hadamard(wires=0)     # Apply Hadamard gate to the second qubit     qml.Hadamard(wires=1)     # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Run the circuit print(\"Hadamard Gate Circuit Output:\", hadamard_gate_circuit()) fig, ax = qml.draw_mpl(hadamard_gate_circuit)() plt.show() <pre>Hadamard Gate Circuit Output: [tensor(0., requires_grad=True), tensor(0., requires_grad=True)]\n</pre> In\u00a0[18]: Copied! <pre>@qml.qnode(dev)\ndef cnot_gate_circuit():\n    # Apply CNOT gate with the first qubit as control and the second qubit as target\n    qml.CNOT(wires=[0, 1])\n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Run the circuit\nprint(\"CNOT Gate Circuit Output:\", cnot_gate_circuit())\nfig, ax = qml.draw_mpl(cnot_gate_circuit)()\nplt.show()\n</pre> @qml.qnode(dev) def cnot_gate_circuit():     # Apply CNOT gate with the first qubit as control and the second qubit as target     qml.CNOT(wires=[0, 1])     # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Run the circuit print(\"CNOT Gate Circuit Output:\", cnot_gate_circuit()) fig, ax = qml.draw_mpl(cnot_gate_circuit)() plt.show() <pre>CNOT Gate Circuit Output: [tensor(1., requires_grad=True), tensor(1., requires_grad=True)]\n</pre> In\u00a0[19]: Copied! <pre>#import pennylane as qml\n#from pennylane import numpy as np\n\n# Create a device with 2 qubits using the default qubit simulator\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef rotation_gates_circuit(angle_x, angle_y, angle_z):\n    # Apply RX rotation gate to the first qubit with angle angle_x\n    qml.RX(angle_x, wires=0)\n    \n    # Apply RY rotation gate to the second qubit with angle angle_y\n    qml.RY(angle_y, wires=1)\n    \n    # Apply RZ rotation gate to the first qubit with angle angle_z\n    qml.RZ(angle_z, wires=0)\n    \n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Example: Set rotation angles for each gate\nangle_x = np.pi / 2   # Rotation angle around the X-axis for Qubit 0\nangle_y = np.pi / 4   # Rotation angle around the Y-axis for Qubit 1\nangle_z = np.pi / 8   # Rotation angle around the Z-axis for Qubit 0\n\n# Run the circuit with the specified angles\nresults = rotation_gates_circuit(angle_x, angle_y, angle_z)\nprint(\"Rotation Gates Circuit Output:\", results)\n\nfig, ax = qml.draw_mpl(rotation_gates_circuit)(angle_x, angle_y, angle_z)\nplt.show()\n</pre> #import pennylane as qml #from pennylane import numpy as np  # Create a device with 2 qubits using the default qubit simulator dev = qml.device('default.qubit', wires=2)  @qml.qnode(dev) def rotation_gates_circuit(angle_x, angle_y, angle_z):     # Apply RX rotation gate to the first qubit with angle angle_x     qml.RX(angle_x, wires=0)          # Apply RY rotation gate to the second qubit with angle angle_y     qml.RY(angle_y, wires=1)          # Apply RZ rotation gate to the first qubit with angle angle_z     qml.RZ(angle_z, wires=0)          # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Example: Set rotation angles for each gate angle_x = np.pi / 2   # Rotation angle around the X-axis for Qubit 0 angle_y = np.pi / 4   # Rotation angle around the Y-axis for Qubit 1 angle_z = np.pi / 8   # Rotation angle around the Z-axis for Qubit 0  # Run the circuit with the specified angles results = rotation_gates_circuit(angle_x, angle_y, angle_z) print(\"Rotation Gates Circuit Output:\", results)  fig, ax = qml.draw_mpl(rotation_gates_circuit)(angle_x, angle_y, angle_z) plt.show() <pre>Rotation Gates Circuit Output: [tensor(2.22044605e-16, requires_grad=True), tensor(0.70710678, requires_grad=True)]\n</pre> In\u00a0[20]: Copied! <pre>@qml.qnode(dev)\ndef swap_gate_circuit():\n    # Apply Hadamard gate to the first qubit to create superposition\n    qml.Hadamard(wires=0)\n    \n    # Apply SWAP gate between the first and second qubits\n    qml.SWAP(wires=[0, 1])\n    \n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Run the circuit\nprint(\"SWAP Gate Circuit Output:\", swap_gate_circuit())\nfig, ax = qml.draw_mpl(swap_gate_circuit)()\nplt.show()\n</pre> @qml.qnode(dev) def swap_gate_circuit():     # Apply Hadamard gate to the first qubit to create superposition     qml.Hadamard(wires=0)          # Apply SWAP gate between the first and second qubits     qml.SWAP(wires=[0, 1])          # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Run the circuit print(\"SWAP Gate Circuit Output:\", swap_gate_circuit()) fig, ax = qml.draw_mpl(swap_gate_circuit)() plt.show() <pre>SWAP Gate Circuit Output: [tensor(1., requires_grad=True), tensor(0., requires_grad=True)]\n</pre> In\u00a0[\u00a0]: Copied! <pre>@qml.qnode(dev)\ndef two_qubit_qft():\n    # TODO: Apply a Hadamard gate to the first qubit\n    # TODO: Apply a controlled-Phase gate (CRZ) between qubits with phase \u03c0/2\n    # TODO: Apply a Hadamard gate to the second qubit\n    # TODO: SWAP the two qubits\n    return qml.state()\n\n# Test your circuit\nprint(\"2-qubit QFT State:\", two_qubit_qft())\n\n# Draw the circuit\n</pre> @qml.qnode(dev) def two_qubit_qft():     # TODO: Apply a Hadamard gate to the first qubit     # TODO: Apply a controlled-Phase gate (CRZ) between qubits with phase \u03c0/2     # TODO: Apply a Hadamard gate to the second qubit     # TODO: SWAP the two qubits     return qml.state()  # Test your circuit print(\"2-qubit QFT State:\", two_qubit_qft())  # Draw the circuit In\u00a0[23]: Copied! <pre># Uncomment to see the answer\n# %load ./2qft.py\n</pre> # Uncomment to see the answer # %load ./2qft.py <p>For more details on PennyLane, see their website.</p> In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport pennylane as qml\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import pennylane as qml import numpy as np In\u00a0[21]: Copied! <pre>NUM_QUBITS = 2\ndev = qml.device(\"default.qubit\", wires=NUM_QUBITS)\nwires = list(range(NUM_QUBITS))\n\ndef equal_superposition(wires):\n    for wire in wires:\n        qml.Hadamard(wires=wire)\n\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Snapshot(\"Initial state\")\n    equal_superposition(wires)\n    qml.Snapshot(\"After applying the Hadamard gates\")\n    return qml.probs(wires=wires)  # Probability of finding a computational basis state on the wires\n\n\nresults = qml.snapshots(circuit)()\n\nfor k, result in results.items():\n    print(f\"{k}: {result}\")\n</pre> NUM_QUBITS = 2 dev = qml.device(\"default.qubit\", wires=NUM_QUBITS) wires = list(range(NUM_QUBITS))  def equal_superposition(wires):     for wire in wires:         qml.Hadamard(wires=wire)   @qml.qnode(dev) def circuit():     qml.Snapshot(\"Initial state\")     equal_superposition(wires)     qml.Snapshot(\"After applying the Hadamard gates\")     return qml.probs(wires=wires)  # Probability of finding a computational basis state on the wires   results = qml.snapshots(circuit)()  for k, result in results.items():     print(f\"{k}: {result}\") <pre>Initial state: [1.+0.j 0.+0.j 0.+0.j 0.+0.j]\nAfter applying the Hadamard gates: [0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j]\nexecution_results: [0.25 0.25 0.25 0.25]\n</pre> <p>Let's use a bar plot to better visualize the initial state amplitudes:</p> In\u00a0[22]: Copied! <pre>y = np.real(results[\"After applying the Hadamard gates\"])\nbit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y))]\n\nplt.bar(bit_strings, y, color = \"#70CEFF\")\n\nplt.xticks(rotation=\"vertical\")\nplt.xlabel(\"State label\")\nplt.ylabel(\"Probability Amplitude\")\nplt.title(\"States probabilities amplitudes\")\nplt.show()\n</pre> y = np.real(results[\"After applying the Hadamard gates\"]) bit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y))]  plt.bar(bit_strings, y, color = \"#70CEFF\")  plt.xticks(rotation=\"vertical\") plt.xlabel(\"State label\") plt.ylabel(\"Probability Amplitude\") plt.title(\"States probabilities amplitudes\") plt.show() <p>As expected, they are equally distributed.</p> In\u00a0[23]: Copied! <pre>dev = qml.device(\"default.qubit\", wires=NUM_QUBITS)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Snapshot(\"Initial state |00&gt;\")\n    # Flipping the marked state\n    qml.FlipSign([0, 0], wires=wires)\n    qml.Snapshot(\"After flipping it\")\n    return qml.state()\n\nresults = qml.snapshots(circuit)()\n\nfor k, result in results.items():\n    print(f\"{k}: {result}\")\n\ny1 = np.real(results[\"Initial state |00&gt;\"])\ny2 = np.real(results[\"After flipping it\"])\n\nbit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y))]\n\nplt.bar(bit_strings, y1, color = \"#70CEFF\")\nplt.bar(bit_strings, y2, color = \"#C756B2\")\n\nplt.xticks(rotation=\"vertical\")\nplt.xlabel(\"State label\")\nplt.ylabel(\"Probability Amplitude\")\nplt.title(\"States probabilities amplitudes\")\n\nplt.legend([\"Initial state |00&gt;\", \"After flipping it\"])\nplt.axhline(y=0.0, color=\"k\", linestyle=\"-\")\nplt.show()\n</pre> dev = qml.device(\"default.qubit\", wires=NUM_QUBITS)  @qml.qnode(dev) def circuit():     qml.Snapshot(\"Initial state |00&gt;\")     # Flipping the marked state     qml.FlipSign([0, 0], wires=wires)     qml.Snapshot(\"After flipping it\")     return qml.state()  results = qml.snapshots(circuit)()  for k, result in results.items():     print(f\"{k}: {result}\")  y1 = np.real(results[\"Initial state |00&gt;\"]) y2 = np.real(results[\"After flipping it\"])  bit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y))]  plt.bar(bit_strings, y1, color = \"#70CEFF\") plt.bar(bit_strings, y2, color = \"#C756B2\")  plt.xticks(rotation=\"vertical\") plt.xlabel(\"State label\") plt.ylabel(\"Probability Amplitude\") plt.title(\"States probabilities amplitudes\")  plt.legend([\"Initial state |00&gt;\", \"After flipping it\"]) plt.axhline(y=0.0, color=\"k\", linestyle=\"-\") plt.show() <pre>Initial state |00&gt;: [1.+0.j 0.+0.j 0.+0.j 0.+0.j]\nAfter flipping it: [-1.+0.j  0.+0.j  0.+0.j  0.+0.j]\nexecution_results: [-1.+0.j  0.+0.j  0.+0.j  0.+0.j]\n</pre> <p>We can see that the amplitude of the state $\\vert 00\\rangle$ flipped. Now, let us prepare the Oracle and inspect its action in the circuit.</p> In\u00a0[24]: Copied! <pre>omega = np.zeros(NUM_QUBITS)\n\ndef oracle(wires, omega):\n    qml.FlipSign(omega, wires=wires)\n\ndev = qml.device(\"default.qubit\", wires=NUM_QUBITS)\n\n@qml.qnode(dev)\ndef circuit():\n    equal_superposition(wires)\n    qml.Snapshot(\"Before querying the Oracle\")\n\n    oracle(wires, omega)\n    qml.Snapshot(\"After querying the Oracle\")\n\n    return qml.probs(wires=wires)\n\nresults = qml.snapshots(circuit)()\n\nfor k, result in results.items():\n    print(f\"{k}: {result}\")\n</pre> omega = np.zeros(NUM_QUBITS)  def oracle(wires, omega):     qml.FlipSign(omega, wires=wires)  dev = qml.device(\"default.qubit\", wires=NUM_QUBITS)  @qml.qnode(dev) def circuit():     equal_superposition(wires)     qml.Snapshot(\"Before querying the Oracle\")      oracle(wires, omega)     qml.Snapshot(\"After querying the Oracle\")      return qml.probs(wires=wires)  results = qml.snapshots(circuit)()  for k, result in results.items():     print(f\"{k}: {result}\") <pre>Before querying the Oracle: [0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j]\nAfter querying the Oracle: [-0.5+0.j  0.5+0.j  0.5+0.j  0.5+0.j]\nexecution_results: [0.25 0.25 0.25 0.25]\n</pre> In\u00a0[25]: Copied! <pre>y1 = np.real(results[\"Before querying the Oracle\"])\ny2 = np.real(results[\"After querying the Oracle\"])\n\nbit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y1))]\n\nbar_width = 0.4\n\nrect_1 = np.arange(0, len(y1))\nrect_2 = [x + bar_width for x in rect_1]\n\nplt.bar(\n    rect_1,\n    y1,\n    width=bar_width,\n    edgecolor=\"white\",\n    color = \"#70CEFF\",\n    label=\"Before querying the Oracle\",\n)\nplt.bar(\n    rect_2,\n    y2,\n    width=bar_width,\n    edgecolor=\"white\",\n    color = \"#C756B2\",\n    label=\"After querying the Oracle\",\n)\n\nplt.xticks(rect_1 + 0.2, bit_strings, rotation=\"vertical\")\nplt.xlabel(\"State label\")\nplt.ylabel(\"Probability Amplitude\")\nplt.title(\"States probabilities amplitudes\")\n\nplt.legend()\nplt.show()\n</pre> y1 = np.real(results[\"Before querying the Oracle\"]) y2 = np.real(results[\"After querying the Oracle\"])  bit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y1))]  bar_width = 0.4  rect_1 = np.arange(0, len(y1)) rect_2 = [x + bar_width for x in rect_1]  plt.bar(     rect_1,     y1,     width=bar_width,     edgecolor=\"white\",     color = \"#70CEFF\",     label=\"Before querying the Oracle\", ) plt.bar(     rect_2,     y2,     width=bar_width,     edgecolor=\"white\",     color = \"#C756B2\",     label=\"After querying the Oracle\", )  plt.xticks(rect_1 + 0.2, bit_strings, rotation=\"vertical\") plt.xlabel(\"State label\") plt.ylabel(\"Probability Amplitude\") plt.title(\"States probabilities amplitudes\")  plt.legend() plt.show() <p>We can see that the amplitude corresponding to the state $\\vert \\omega \\rangle$ changed. However, we need an additional step to find the solution, since the probability of measuring any of the states remains equally distributed. This can be solved by applying the Grover diffusion operator, defined as</p> <p>$$U_D = 2| s \\rangle\\langle s| - \\mathbb{I}.$$</p> <p>The unitary $U_D$ also acts as a rotation, but this time through the uniform superposition $\\vert s \\rangle$. Finally, the combination of $U_{\\omega}$ with $U_D$ rotates the state $\\vert s \\rangle$ by an angle of $\\theta =2 \\arcsin{\\tfrac {1}{\\sqrt {N}}}$.</p> <p>In a 2-qubit circuit, the diffusion operator has a specific shape:</p> <p>Now, we have all the building blocks to implement a single-item search in a 2-qubit circuit. We can verify in the circuit below that applying the Grover iterator $U_D U_\\omega$ once is enough to solve the problem.</p> In\u00a0[26]: Copied! <pre>dev = qml.device(\"default.qubit\", wires=NUM_QUBITS)\n\n\ndef diffusion_operator(wires):\n    for wire in wires:\n        qml.Hadamard(wires=wire)\n        qml.PauliZ(wires=wire)\n    qml.ctrl(qml.PauliZ, 0)(wires=1)\n    for wire in wires:\n        qml.Hadamard(wires=wire)\n\n\n@qml.qnode(dev)\ndef circuit():\n    equal_superposition(wires)\n    qml.Snapshot(\"Uniform superposition |s&gt;\")\n\n    oracle(wires, omega)\n    qml.Snapshot(\"State marked by Oracle\")\n    diffusion_operator(wires)\n\n    qml.Snapshot(\"Amplitude after diffusion\")\n    return qml.probs(wires=wires)\n\n\nresults = qml.snapshots(circuit)()\n\nfor k, result in results.items():\n    print(f\"{k}: {result}\")\n</pre> dev = qml.device(\"default.qubit\", wires=NUM_QUBITS)   def diffusion_operator(wires):     for wire in wires:         qml.Hadamard(wires=wire)         qml.PauliZ(wires=wire)     qml.ctrl(qml.PauliZ, 0)(wires=1)     for wire in wires:         qml.Hadamard(wires=wire)   @qml.qnode(dev) def circuit():     equal_superposition(wires)     qml.Snapshot(\"Uniform superposition |s&gt;\")      oracle(wires, omega)     qml.Snapshot(\"State marked by Oracle\")     diffusion_operator(wires)      qml.Snapshot(\"Amplitude after diffusion\")     return qml.probs(wires=wires)   results = qml.snapshots(circuit)()  for k, result in results.items():     print(f\"{k}: {result}\") <pre>Uniform superposition |s&gt;: [0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j]\nState marked by Oracle: [-0.5+0.j  0.5+0.j  0.5+0.j  0.5+0.j]\nAmplitude after diffusion: [1.+0.j 0.+0.j 0.+0.j 0.+0.j]\nexecution_results: [1. 0. 0. 0.]\n</pre> In\u00a0[27]: Copied! <pre>NUM_QUBITS = 5\n\nomega = np.array([np.zeros(NUM_QUBITS), np.ones(NUM_QUBITS)])\n\nM = len(omega)\nN = 2**NUM_QUBITS\nwires = list(range(NUM_QUBITS))\n\ndev = qml.device(\"default.qubit\", wires=NUM_QUBITS)\n\n@qml.qnode(dev)\ndef circuit():\n    iterations = int(np.round(np.sqrt(N / M) * np.pi / 4))\n\n    # Initial state preparation\n    equal_superposition(wires)\n\n    # Grover's iterator\n    for _ in range(iterations):\n        for omg in omega:\n            oracle(wires, omg)\n        qml.templates.GroverOperator(wires)\n\n    return qml.probs(wires=wires)\n\n\nresults = qml.snapshots(circuit)()\n\nfor k, result in results.items():\n    print(f\"{k}: {result}\")\n</pre> NUM_QUBITS = 5  omega = np.array([np.zeros(NUM_QUBITS), np.ones(NUM_QUBITS)])  M = len(omega) N = 2**NUM_QUBITS wires = list(range(NUM_QUBITS))  dev = qml.device(\"default.qubit\", wires=NUM_QUBITS)  @qml.qnode(dev) def circuit():     iterations = int(np.round(np.sqrt(N / M) * np.pi / 4))      # Initial state preparation     equal_superposition(wires)      # Grover's iterator     for _ in range(iterations):         for omg in omega:             oracle(wires, omg)         qml.templates.GroverOperator(wires)      return qml.probs(wires=wires)   results = qml.snapshots(circuit)()  for k, result in results.items():     print(f\"{k}: {result}\") <pre>execution_results: [0.48065948 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937\n 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937\n 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937\n 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937\n 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937 0.00128937\n 0.00128937 0.48065948]\n</pre> <p>Let us use a bar plot to visualize the probability to find the correct bitstring.</p> In\u00a0[28]: Copied! <pre>y = results[\"execution_results\"]\nbit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y))]\n\nplt.bar(bit_strings, results[\"execution_results\"], color = \"#70CEFF\")\n\nplt.xticks(rotation=\"vertical\")\nplt.xlabel(\"State label\")\nplt.ylabel(\"Probability\")\nplt.title(\"States probabilities\")\n\nplt.show()\n</pre> y = results[\"execution_results\"] bit_strings = [f\"{x:0{NUM_QUBITS}b}\" for x in range(len(y))]  plt.bar(bit_strings, results[\"execution_results\"], color = \"#70CEFF\")  plt.xticks(rotation=\"vertical\") plt.xlabel(\"State label\") plt.ylabel(\"Probability\") plt.title(\"States probabilities\")  plt.show() <p>Oracle function:</p> In\u00a0[35]: Copied! <pre>import pennylane as qml\nfrom pennylane import numpy as np\n\nproperty_price = [4, 8, 6, 3, 12, 15] #Unis in thousands of dollars\n\nvariables_wires = [0,1,2,3,4,5]\naux_oracle_wires = [6,7,8,9,10,11]\n\ndef oracle(variables_wires, aux_oracle_wires):\n\n    def add_k_fourier(k, wires):\n        for j in range(len(wires)):\n            qml.RZ(k * np.pi / (2**j), wires=wires[j])\n\n    def value_second_sibling():\n        qml.QFT(wires = aux_oracle_wires)\n        for wire in variables_wires:\n            qml.ctrl(add_k_fourier, control = wire)(\n                property_price[wire],\n                wires = aux_oracle_wires\n            )\n        qml.adjoint(qml.QFT)(wires = aux_oracle_wires)\n\n    value_second_sibling()\n    qml.FlipSign(\n        sum(property_price) // 2,\n        wires = aux_oracle_wires\n    )\n    qml.adjoint(value_second_sibling)()\n\ndev = qml.device(\"default.qubit\", wires = variables_wires + aux_oracle_wires)\n#dev = qml.device(\"default.qubit\", wires = variables_wires + aux_oracle_wires, shots = 1)\n\n@qml.qnode(dev)\ndef circuit():\n    # Step 1, supersposition state\n    for wire in variables_wires:\n        qml.Hadamard(wires=wire)\n\n    # step 2, apply oracle\n    for _ in range(3):\n        oracle(variables_wires, aux_oracle_wires)\n\n        # Step 3, amplification\n        qml.GroverOperator(wires = variables_wires)\n\n    return qml.probs(wires = variables_wires)\n    #return qml.sample(wires = variables_wires)\n\nimport matplotlib.pyplot as pyplot\n\nvalues = circuit()\nplt.bar(range(len(values)), values)\n#print(values)\n</pre> import pennylane as qml from pennylane import numpy as np  property_price = [4, 8, 6, 3, 12, 15] #Unis in thousands of dollars  variables_wires = [0,1,2,3,4,5] aux_oracle_wires = [6,7,8,9,10,11]  def oracle(variables_wires, aux_oracle_wires):      def add_k_fourier(k, wires):         for j in range(len(wires)):             qml.RZ(k * np.pi / (2**j), wires=wires[j])      def value_second_sibling():         qml.QFT(wires = aux_oracle_wires)         for wire in variables_wires:             qml.ctrl(add_k_fourier, control = wire)(                 property_price[wire],                 wires = aux_oracle_wires             )         qml.adjoint(qml.QFT)(wires = aux_oracle_wires)      value_second_sibling()     qml.FlipSign(         sum(property_price) // 2,         wires = aux_oracle_wires     )     qml.adjoint(value_second_sibling)()  dev = qml.device(\"default.qubit\", wires = variables_wires + aux_oracle_wires) #dev = qml.device(\"default.qubit\", wires = variables_wires + aux_oracle_wires, shots = 1)  @qml.qnode(dev) def circuit():     # Step 1, supersposition state     for wire in variables_wires:         qml.Hadamard(wires=wire)      # step 2, apply oracle     for _ in range(3):         oracle(variables_wires, aux_oracle_wires)          # Step 3, amplification         qml.GroverOperator(wires = variables_wires)      return qml.probs(wires = variables_wires)     #return qml.sample(wires = variables_wires)  import matplotlib.pyplot as pyplot  values = circuit() plt.bar(range(len(values)), values) #print(values) Out[35]: <pre>&lt;BarContainer object of 64 artists&gt;</pre> In\u00a0[36]: Copied! <pre>#import pennylane as qml\nimport numpy as np\n\ndef state_preparation(state):\n    qml.StatePrep(state, wires=[\"S\"])\n</pre> #import pennylane as qml import numpy as np  def state_preparation(state):     qml.StatePrep(state, wires=[\"S\"]) In\u00a0[37]: Copied! <pre>def entangle_qubits():\n    qml.Hadamard(wires=\"A\")\n    qml.CNOT(wires=[\"A\", \"B\"])\n</pre> def entangle_qubits():     qml.Hadamard(wires=\"A\")     qml.CNOT(wires=[\"A\", \"B\"]) <p>From now on, the qubit subscripts will be removed from states for brevity.</p> In\u00a0[38]: Copied! <pre>def basis_rotation():\n    qml.CNOT(wires=[\"S\", \"A\"])\n    qml.Hadamard(wires=\"S\")\n</pre> def basis_rotation():     qml.CNOT(wires=[\"S\", \"A\"])     qml.Hadamard(wires=\"S\") In\u00a0[39]: Copied! <pre>def measure_and_update():\n    m0 = qml.measure(\"S\")\n    m1 = qml.measure(\"A\")\n    qml.cond(m1, qml.PauliX)(\"B\")\n    qml.cond(m0, qml.PauliZ)(\"B\")\n</pre> def measure_and_update():     m0 = qml.measure(\"S\")     m1 = qml.measure(\"A\")     qml.cond(m1, qml.PauliX)(\"B\")     qml.cond(m0, qml.PauliZ)(\"B\") <p>We've now defined all the building blocks for the quantum teleportation protocol. Let's put it all together!</p> In\u00a0[40]: Copied! <pre>def teleport(state):\n    state_preparation(state)\n    entangle_qubits()\n    basis_rotation()\n    measure_and_update()\n\n\nstate = np.array([1 / np.sqrt(2) + 0.3j, 0.4 - 0.5j])\n_ = qml.draw_mpl(teleport, style=\"pennylane\")(state)\n</pre> def teleport(state):     state_preparation(state)     entangle_qubits()     basis_rotation()     measure_and_update()   state = np.array([1 / np.sqrt(2) + 0.3j, 0.4 - 0.5j]) _ = qml.draw_mpl(teleport, style=\"pennylane\")(state) <p>There is a neat concept known as the principle of deferred measurement, and it basically states that we can push all our measurements to the end of our circuit. This can be useful for a variety of reasons, such as when working in a system that does not support mid-circuit measurements. In PennyLane, when you bind a circuit to a device that does not support them, it will automatically apply the principle of deferred measurement and update your circuit to use controlled operations instead. Note that you need to specify <code>expansion_strategy=\"device\"</code> when calling <code>draw_mpl</code> so it runs the device pre-processing before drawing the circuit.</p> In\u00a0[43]: Copied! <pre>dev = qml.device(\"default.qubit\", wires=[\"S\", \"A\", \"B\"])\n\n@qml.qnode(dev)\ndef teleport(state):\n    state_preparation(state)\n    entangle_qubits()\n    basis_rotation()\n    measure_and_update()\n    return qml.density_matrix(wires=[\"B\"])\n\n\n_ = qml.draw_mpl(teleport, style=\"pennylane\", expansion_strategy=\"device\")(state)\n</pre> dev = qml.device(\"default.qubit\", wires=[\"S\", \"A\", \"B\"])  @qml.qnode(dev) def teleport(state):     state_preparation(state)     entangle_qubits()     basis_rotation()     measure_and_update()     return qml.density_matrix(wires=[\"B\"])   _ = qml.draw_mpl(teleport, style=\"pennylane\", expansion_strategy=\"device\")(state) Out[43]: <pre>''</pre> <p>Poof! Our classical signals have been turned into CNOT and CZ gates. This is exactly what the principle of deferred measurement gives us --- we can apply a CNOT instead of Alice calling Bob and telling him to apply an X gate, and likewise for the CZ gate. This is incredibly useful, as it allows us to perform our correction before any measurements are made. Let's evaluate the action of the CNOT and CZ on Bob's qubit, and ensure that Alice's state has been successfully teleported. Applying the CNOT yields:</p> <p>$$\\frac{1}{2} \\vert 00\\rangle(\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 01\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 10\\rangle (\\alpha\\vert 0\\rangle - \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 11\\rangle (\\alpha\\vert 0\\rangle - \\beta\\vert 1\\rangle)$$</p> <p>Then, applying the CZ yields:</p> <p>$$\\frac{1}{2} \\vert 00\\rangle(\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 01\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 10\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 11\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle)\\tag{3}$$</p> <p>When Alice measures her two qubits at the end, no matter which outcome she gets, Bob's qubit will be in the state $\\alpha\\vert 0\\rangle + \\beta \\vert 1\\rangle$. This means that our protocol has changed the state of Bob's qubit into the one Alice wished to send him, which is truly incredible!</p> <p>We can use <code>qml.density_matrix</code> to trace out and return Bob's subsystem as a density matrix, which is a more general description of the state of his qubit. We will use this to verify that Alice's state was successfully teleported to Bob's qubit. Re-arranging equation (3), we can see that the final state of the system is:</p> <p>$$\\frac{1}{2} (\\vert 00\\rangle + \\vert 01\\rangle + \\vert 10\\rangle + \\vert 11\\rangle) \\vert \\psi\\rangle\\tag{4}$$</p> <p>Now, we can confirm that our implementation of the quantum teleportation protocol is working as expected by comparing Bob's final density matrix to Alice's original density matrix:</p> In\u00a0[44]: Copied! <pre>def teleport_state(state):\n    teleported_density_matrix = teleport(state)\n    original_density_matrix = qml.math.dm_from_state_vector(state)\n\n    if not np.allclose(teleported_density_matrix, original_density_matrix):\n        raise ValueError(\n            f\"Alice's state ({state}) not teleported properly. \"\n            f\"Final density matrix of Bob's subsystem: {teleported_density_matrix}\"\n        )\n    print(\"State successfully teleported!\")\n\nteleport_state(state)\n</pre> def teleport_state(state):     teleported_density_matrix = teleport(state)     original_density_matrix = qml.math.dm_from_state_vector(state)      if not np.allclose(teleported_density_matrix, original_density_matrix):         raise ValueError(             f\"Alice's state ({state}) not teleported properly. \"             f\"Final density matrix of Bob's subsystem: {teleported_density_matrix}\"         )     print(\"State successfully teleported!\")  teleport_state(state) <pre>State successfully teleported!\n</pre> <p>Reload modules</p> In\u00a0[45]: Copied! <pre>#import pennylane as qml\nfrom pennylane import numpy as np\nfrom pennylane.templates import RandomLayers\nimport tensorflow as tf\nfrom tensorflow import keras\n#import matplotlib.pyplot as plt\n</pre> #import pennylane as qml from pennylane import numpy as np from pennylane.templates import RandomLayers import tensorflow as tf from tensorflow import keras #import matplotlib.pyplot as plt <pre>2024-09-23 15:56:32.103201: E external/local_xla/xla/stream_executor/cuda/cuda_dnn.cc:9261] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\n2024-09-23 15:56:32.103268: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:607] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\n2024-09-23 15:56:32.301065: E external/local_xla/xla/stream_executor/cuda/cuda_blas.cc:1515] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n</pre> <p>Setting of the main hyper-parameters of the model</p> In\u00a0[46]: Copied! <pre>n_epochs = 30   # Number of optimization epochs\nn_layers = 2    # Number of random layers\nn_train = 250   # Size of the train dataset\nn_test = 30     # Size of the test dataset\n\nSAVE_PATH = \"../save/quanvolution/\"  # Data saving folder\nPREPROCESS = True           # If False, skip quantum processing and load data from SAVE_PATH\nnp.random.seed(0)           # Seed for NumPy random number generator\ntf.random.set_seed(0)       # Seed for TensorFlow random number generator\n</pre> n_epochs = 30   # Number of optimization epochs n_layers = 2    # Number of random layers n_train = 250   # Size of the train dataset n_test = 30     # Size of the test dataset  SAVE_PATH = \"../save/quanvolution/\"  # Data saving folder PREPROCESS = True           # If False, skip quantum processing and load data from SAVE_PATH np.random.seed(0)           # Seed for NumPy random number generator tf.random.set_seed(0)       # Seed for TensorFlow random number generator In\u00a0[47]: Copied! <pre>mnist_dataset = keras.datasets.mnist\n(train_images, train_labels), (test_images, test_labels) = mnist_dataset.load_data()\n\n# Reduce dataset size\ntrain_images = train_images[:n_train]\ntrain_labels = train_labels[:n_train]\ntest_images = test_images[:n_test]\ntest_labels = test_labels[:n_test]\n\n# Normalize pixel values within 0 and 1\ntrain_images = train_images / 255\ntest_images = test_images / 255\n\n# Add extra dimension for convolution channels\ntrain_images = np.array(train_images[..., tf.newaxis], requires_grad=False)\ntest_images = np.array(test_images[..., tf.newaxis], requires_grad=False)\n</pre> mnist_dataset = keras.datasets.mnist (train_images, train_labels), (test_images, test_labels) = mnist_dataset.load_data()  # Reduce dataset size train_images = train_images[:n_train] train_labels = train_labels[:n_train] test_images = test_images[:n_test] test_labels = test_labels[:n_test]  # Normalize pixel values within 0 and 1 train_images = train_images / 255 test_images = test_images / 255  # Add extra dimension for convolution channels train_images = np.array(train_images[..., tf.newaxis], requires_grad=False) test_images = np.array(test_images[..., tf.newaxis], requires_grad=False) In\u00a0[48]: Copied! <pre>dev = qml.device(\"lightning.qubit\", wires=4)\n\n# Random circuit parameters\nrand_params = np.random.uniform(high=2 * np.pi, size=(n_layers, 4))\n\n@qml.qnode(dev)\ndef circuit(phi):\n    # Encoding of 4 classical input values\n    for j in range(4):\n        qml.RY(np.pi * phi[j], wires=j)\n\n    # Random quantum circuit\n    RandomLayers(rand_params, wires=list(range(4)))\n\n    # Measurement producing 4 classical output values\n    return [qml.expval(qml.PauliZ(j)) for j in range(4)]\n</pre> dev = qml.device(\"lightning.qubit\", wires=4)  # Random circuit parameters rand_params = np.random.uniform(high=2 * np.pi, size=(n_layers, 4))  @qml.qnode(dev) def circuit(phi):     # Encoding of 4 classical input values     for j in range(4):         qml.RY(np.pi * phi[j], wires=j)      # Random quantum circuit     RandomLayers(rand_params, wires=list(range(4)))      # Measurement producing 4 classical output values     return [qml.expval(qml.PauliZ(j)) for j in range(4)] In\u00a0[49]: Copied! <pre># Example to show the circuit\nnp.random.seed(42)\nphi = np.random.uniform(high=1/4 * np.pi, size=(n_layers, 4))\nprint(phi)\nprint(qml.draw(circuit, level=\"device\")(phi[0]))\nfig, ax = qml.draw_mpl(circuit, level=\"device\")(phi[0])\nplt.show()\n_ = qml.draw_mpl(circuit, style=\"pennylane_sketch\")(phi[0])\n</pre> # Example to show the circuit np.random.seed(42) phi = np.random.uniform(high=1/4 * np.pi, size=(n_layers, 4)) print(phi) print(qml.draw(circuit, level=\"device\")(phi[0])) fig, ax = qml.draw_mpl(circuit, level=\"device\")(phi[0]) plt.show() _ = qml.draw_mpl(circuit, style=\"pennylane_sketch\")(phi[0]) <pre>[[0.29416312 0.74668927 0.5749067  0.47018527]\n [0.12253675 0.12251781 0.04561876 0.68029315]]\n0: \u2500\u2500RY(0.92)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dX\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  &lt;Z&gt;\n1: \u2500\u2500RY(2.35)\u2500\u2500RY(3.72)\u2500\u256d\u25cf\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RY(0.36)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  &lt;Z&gt;\n2: \u2500\u2500RY(1.81)\u2500\u2500RX(5.30)\u2500\u2502\u2500\u2500\u2500RZ(5.39)\u2500\u2500RX(5.32)\u2500\u2500RY(2.42)\u2500\u256dX\u2500\u2500RY(1.87)\u2500\u2524  &lt;Z&gt;\n3: \u2500\u2500RY(1.48)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(3.92)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  &lt;Z&gt;\n</pre> <p>The next function defines the convolution scheme:</p> <ol> <li><p>the image is divided into squares of $2\u00d72$ pixels;</p> </li> <li><p>each square is processed by the quantum circuit;</p> </li> <li><p>the $4$ expectation values are mapped into $4$ different channels of a single output pixel.</p> </li> </ol> In\u00a0[50]: Copied! <pre>def quanv(image):\n\"\"\"Convolves the input image with many applications of the same quantum circuit.\"\"\"\n    out = np.zeros((14, 14, 4))\n\n    # Loop over the coordinates of the top-left pixel of 2X2 squares\n    for j in range(0, 28, 2):\n        for k in range(0, 28, 2):\n            # Process a squared 2x2 region of the image with a quantum circuit\n            q_results = circuit(\n                [\n                    image[j, k, 0],\n                    image[j, k + 1, 0],\n                    image[j + 1, k, 0],\n                    image[j + 1, k + 1, 0]\n                ]\n            )\n            # Assign expectation values to different channels of the output pixel (j/2, k/2)\n            for c in range(4):\n                out[j // 2, k // 2, c] = q_results[c]\n    return out\n</pre> def quanv(image):     \"\"\"Convolves the input image with many applications of the same quantum circuit.\"\"\"     out = np.zeros((14, 14, 4))      # Loop over the coordinates of the top-left pixel of 2X2 squares     for j in range(0, 28, 2):         for k in range(0, 28, 2):             # Process a squared 2x2 region of the image with a quantum circuit             q_results = circuit(                 [                     image[j, k, 0],                     image[j, k + 1, 0],                     image[j + 1, k, 0],                     image[j + 1, k + 1, 0]                 ]             )             # Assign expectation values to different channels of the output pixel (j/2, k/2)             for c in range(4):                 out[j // 2, k // 2, c] = q_results[c]     return out In\u00a0[51]: Copied! <pre>if PREPROCESS == True:\n    q_train_images = []\n    print(\"Quantum pre-processing of train images:\")\n    for idx, img in enumerate(train_images):\n        print(\"{}/{}        \".format(idx + 1, n_train), end=\"\\r\")\n        q_train_images.append(quanv(img))\n    q_train_images = np.asarray(q_train_images)\n\n    q_test_images = []\n    print(\"\\nQuantum pre-processing of test images:\")\n    for idx, img in enumerate(test_images):\n        print(\"{}/{}        \".format(idx + 1, n_test), end=\"\\r\")\n        q_test_images.append(quanv(img))\n    q_test_images = np.asarray(q_test_images)\n\n    # Save pre-processed images\n    np.save(SAVE_PATH + \"q_train_images.npy\", q_train_images)\n    np.save(SAVE_PATH + \"q_test_images.npy\", q_test_images)\n\n\n# Load pre-processed images\nq_train_images = np.load(SAVE_PATH + \"q_train_images.npy\")\nq_test_images = np.load(SAVE_PATH + \"q_test_images.npy\")\n</pre> if PREPROCESS == True:     q_train_images = []     print(\"Quantum pre-processing of train images:\")     for idx, img in enumerate(train_images):         print(\"{}/{}        \".format(idx + 1, n_train), end=\"\\r\")         q_train_images.append(quanv(img))     q_train_images = np.asarray(q_train_images)      q_test_images = []     print(\"\\nQuantum pre-processing of test images:\")     for idx, img in enumerate(test_images):         print(\"{}/{}        \".format(idx + 1, n_test), end=\"\\r\")         q_test_images.append(quanv(img))     q_test_images = np.asarray(q_test_images)      # Save pre-processed images     np.save(SAVE_PATH + \"q_train_images.npy\", q_train_images)     np.save(SAVE_PATH + \"q_test_images.npy\", q_test_images)   # Load pre-processed images q_train_images = np.load(SAVE_PATH + \"q_train_images.npy\") q_test_images = np.load(SAVE_PATH + \"q_test_images.npy\") <pre>Quantum pre-processing of train images:\n250/250        \nQuantum pre-processing of test images:\n30/30        \r</pre> <p>Let us visualize the effect of the quantum convolution layer on a batch of samples:</p> In\u00a0[52]: Copied! <pre>n_samples = 4\nn_channels = 4\nfig, axes = plt.subplots(1 + n_channels, n_samples, figsize=(10, 10))\nfor k in range(n_samples):\n    axes[0, 0].set_ylabel(\"Input\")\n    if k != 0:\n        axes[0, k].yaxis.set_visible(False)\n    axes[0, k].imshow(train_images[k, :, :, 0], cmap=\"gray\")\n\n    # Plot all output channels\n    for c in range(n_channels):\n        axes[c + 1, 0].set_ylabel(\"Output [ch. {}]\".format(c))\n        if k != 0:\n            axes[c, k].yaxis.set_visible(False)\n        axes[c + 1, k].imshow(q_train_images[k, :, :, c], cmap=\"gray\")\n\nplt.tight_layout()\nplt.show()\n</pre> n_samples = 4 n_channels = 4 fig, axes = plt.subplots(1 + n_channels, n_samples, figsize=(10, 10)) for k in range(n_samples):     axes[0, 0].set_ylabel(\"Input\")     if k != 0:         axes[0, k].yaxis.set_visible(False)     axes[0, k].imshow(train_images[k, :, :, 0], cmap=\"gray\")      # Plot all output channels     for c in range(n_channels):         axes[c + 1, 0].set_ylabel(\"Output [ch. {}]\".format(c))         if k != 0:             axes[c, k].yaxis.set_visible(False)         axes[c + 1, k].imshow(q_train_images[k, :, :, c], cmap=\"gray\")  plt.tight_layout() plt.show() <p>Below each input image, the $4$ output channels generated by the quantum convolution are visualized in gray scale.</p> <p>One can clearly notice the downsampling of the resolution and some local distortion introduced by the quantum kernel. On the other hand the global shape of the image is preserved, as expected for a convolution layer.</p> In\u00a0[53]: Copied! <pre>def MyModel():\n\"\"\"Initializes and returns a custom Keras model\n    which is ready to be trained.\"\"\"\n    model = keras.models.Sequential([\n        keras.layers.Flatten(),\n        keras.layers.Dense(10, activation=\"softmax\")\n    ])\n\n    model.compile(\n        optimizer='adam',\n        loss=\"sparse_categorical_crossentropy\",\n        metrics=[\"accuracy\"],\n    )\n    return model\n</pre> def MyModel():     \"\"\"Initializes and returns a custom Keras model     which is ready to be trained.\"\"\"     model = keras.models.Sequential([         keras.layers.Flatten(),         keras.layers.Dense(10, activation=\"softmax\")     ])      model.compile(         optimizer='adam',         loss=\"sparse_categorical_crossentropy\",         metrics=[\"accuracy\"],     )     return model In\u00a0[54]: Copied! <pre>q_model = MyModel()\n\nq_history = q_model.fit(\n    q_train_images,\n    train_labels,\n    validation_data=(q_test_images, test_labels),\n    batch_size=4,\n    epochs=n_epochs,\n    verbose=2,\n)\n</pre> q_model = MyModel()  q_history = q_model.fit(     q_train_images,     train_labels,     validation_data=(q_test_images, test_labels),     batch_size=4,     epochs=n_epochs,     verbose=2, ) <pre>Epoch 1/30\n</pre> <pre>WARNING: All log messages before absl::InitializeLog() is called are written to STDERR\nI0000 00:00:1727100202.638607    7519 device_compiler.h:186] Compiled cluster using XLA!  This line is logged at most once for the lifetime of the process.\n</pre> <pre>63/63 - 15s - loss: 2.1502 - accuracy: 0.2800 - val_loss: 1.7257 - val_accuracy: 0.5333 - 15s/epoch - 240ms/step\nEpoch 2/30\n63/63 - 0s - loss: 1.3807 - accuracy: 0.6320 - val_loss: 1.3938 - val_accuracy: 0.7000 - 118ms/epoch - 2ms/step\nEpoch 3/30\n63/63 - 0s - loss: 0.9973 - accuracy: 0.7480 - val_loss: 1.2563 - val_accuracy: 0.7000 - 120ms/epoch - 2ms/step\nEpoch 4/30\n63/63 - 0s - loss: 0.7896 - accuracy: 0.8280 - val_loss: 1.0933 - val_accuracy: 0.7333 - 124ms/epoch - 2ms/step\nEpoch 5/30\n63/63 - 0s - loss: 0.6385 - accuracy: 0.8720 - val_loss: 0.9356 - val_accuracy: 0.7333 - 119ms/epoch - 2ms/step\nEpoch 6/30\n63/63 - 0s - loss: 0.5077 - accuracy: 0.9120 - val_loss: 0.9382 - val_accuracy: 0.7333 - 126ms/epoch - 2ms/step\nEpoch 7/30\n63/63 - 0s - loss: 0.4403 - accuracy: 0.9240 - val_loss: 0.8967 - val_accuracy: 0.7000 - 128ms/epoch - 2ms/step\nEpoch 8/30\n63/63 - 0s - loss: 0.3691 - accuracy: 0.9440 - val_loss: 0.8226 - val_accuracy: 0.7000 - 128ms/epoch - 2ms/step\nEpoch 9/30\n63/63 - 0s - loss: 0.3450 - accuracy: 0.9440 - val_loss: 0.7979 - val_accuracy: 0.7667 - 120ms/epoch - 2ms/step\nEpoch 10/30\n63/63 - 0s - loss: 0.2984 - accuracy: 0.9600 - val_loss: 0.7588 - val_accuracy: 0.7667 - 119ms/epoch - 2ms/step\nEpoch 11/30\n63/63 - 0s - loss: 0.2656 - accuracy: 0.9600 - val_loss: 0.7899 - val_accuracy: 0.7000 - 119ms/epoch - 2ms/step\nEpoch 12/30\n63/63 - 0s - loss: 0.2320 - accuracy: 0.9720 - val_loss: 0.8032 - val_accuracy: 0.7333 - 121ms/epoch - 2ms/step\nEpoch 13/30\n63/63 - 0s - loss: 0.2072 - accuracy: 0.9720 - val_loss: 0.6890 - val_accuracy: 0.7333 - 119ms/epoch - 2ms/step\nEpoch 14/30\n63/63 - 0s - loss: 0.1893 - accuracy: 0.9800 - val_loss: 0.7521 - val_accuracy: 0.7333 - 122ms/epoch - 2ms/step\nEpoch 15/30\n63/63 - 0s - loss: 0.1678 - accuracy: 0.9880 - val_loss: 0.7228 - val_accuracy: 0.7333 - 126ms/epoch - 2ms/step\nEpoch 16/30\n63/63 - 0s - loss: 0.1493 - accuracy: 0.9840 - val_loss: 0.6824 - val_accuracy: 0.7333 - 122ms/epoch - 2ms/step\nEpoch 17/30\n63/63 - 0s - loss: 0.1418 - accuracy: 0.9960 - val_loss: 0.6995 - val_accuracy: 0.7000 - 120ms/epoch - 2ms/step\nEpoch 18/30\n63/63 - 0s - loss: 0.1258 - accuracy: 0.9920 - val_loss: 0.7309 - val_accuracy: 0.7333 - 119ms/epoch - 2ms/step\nEpoch 19/30\n63/63 - 0s - loss: 0.1176 - accuracy: 0.9960 - val_loss: 0.6668 - val_accuracy: 0.7333 - 118ms/epoch - 2ms/step\nEpoch 20/30\n63/63 - 0s - loss: 0.1033 - accuracy: 0.9920 - val_loss: 0.7246 - val_accuracy: 0.7000 - 121ms/epoch - 2ms/step\nEpoch 21/30\n63/63 - 0s - loss: 0.0970 - accuracy: 0.9960 - val_loss: 0.6881 - val_accuracy: 0.7667 - 120ms/epoch - 2ms/step\nEpoch 22/30\n63/63 - 0s - loss: 0.0886 - accuracy: 0.9960 - val_loss: 0.6963 - val_accuracy: 0.7000 - 119ms/epoch - 2ms/step\nEpoch 23/30\n63/63 - 0s - loss: 0.0821 - accuracy: 1.0000 - val_loss: 0.7099 - val_accuracy: 0.7333 - 121ms/epoch - 2ms/step\nEpoch 24/30\n63/63 - 0s - loss: 0.0749 - accuracy: 1.0000 - val_loss: 0.6362 - val_accuracy: 0.7333 - 121ms/epoch - 2ms/step\nEpoch 25/30\n63/63 - 0s - loss: 0.0711 - accuracy: 1.0000 - val_loss: 0.7390 - val_accuracy: 0.7333 - 120ms/epoch - 2ms/step\nEpoch 26/30\n63/63 - 0s - loss: 0.0651 - accuracy: 1.0000 - val_loss: 0.6461 - val_accuracy: 0.7333 - 121ms/epoch - 2ms/step\nEpoch 27/30\n63/63 - 0s - loss: 0.0623 - accuracy: 1.0000 - val_loss: 0.6867 - val_accuracy: 0.7000 - 121ms/epoch - 2ms/step\nEpoch 28/30\n63/63 - 0s - loss: 0.0557 - accuracy: 1.0000 - val_loss: 0.6518 - val_accuracy: 0.7000 - 121ms/epoch - 2ms/step\nEpoch 29/30\n63/63 - 0s - loss: 0.0523 - accuracy: 1.0000 - val_loss: 0.6997 - val_accuracy: 0.7333 - 122ms/epoch - 2ms/step\nEpoch 30/30\n63/63 - 0s - loss: 0.0492 - accuracy: 1.0000 - val_loss: 0.6829 - val_accuracy: 0.7333 - 118ms/epoch - 2ms/step\n</pre> <p>In order to compare the results achievable with and without the quantum convolution layer, we initialize also a \u201cclassical\u201d instance of the model that will be directly trained and validated with the raw MNIST images (i.e., without quantum pre-processing).</p> In\u00a0[55]: Copied! <pre>c_model = MyModel()\n\nc_history = c_model.fit(\n    train_images,\n    train_labels,\n    validation_data=(test_images, test_labels),\n    batch_size=4,\n    epochs=n_epochs,\n    verbose=2,\n)\n</pre> c_model = MyModel()  c_history = c_model.fit(     train_images,     train_labels,     validation_data=(test_images, test_labels),     batch_size=4,     epochs=n_epochs,     verbose=2, ) <pre>Epoch 1/30\n63/63 - 7s - loss: 2.0445 - accuracy: 0.3320 - val_loss: 1.6324 - val_accuracy: 0.6000 - 7s/epoch - 105ms/step\nEpoch 2/30\n63/63 - 0s - loss: 1.2278 - accuracy: 0.7920 - val_loss: 1.2291 - val_accuracy: 0.7667 - 119ms/epoch - 2ms/step\nEpoch 3/30\n63/63 - 0s - loss: 0.8515 - accuracy: 0.8720 - val_loss: 1.0170 - val_accuracy: 0.7333 - 119ms/epoch - 2ms/step\nEpoch 4/30\n63/63 - 0s - loss: 0.6513 - accuracy: 0.9120 - val_loss: 0.9141 - val_accuracy: 0.7333 - 127ms/epoch - 2ms/step\nEpoch 5/30\n63/63 - 0s - loss: 0.5285 - accuracy: 0.9160 - val_loss: 0.8359 - val_accuracy: 0.7667 - 239ms/epoch - 4ms/step\nEpoch 6/30\n63/63 - 0s - loss: 0.4438 - accuracy: 0.9280 - val_loss: 0.8056 - val_accuracy: 0.8000 - 121ms/epoch - 2ms/step\nEpoch 7/30\n63/63 - 0s - loss: 0.3813 - accuracy: 0.9280 - val_loss: 0.7347 - val_accuracy: 0.8000 - 118ms/epoch - 2ms/step\nEpoch 8/30\n63/63 - 0s - loss: 0.3311 - accuracy: 0.9560 - val_loss: 0.7433 - val_accuracy: 0.8000 - 118ms/epoch - 2ms/step\nEpoch 9/30\n63/63 - 0s - loss: 0.2914 - accuracy: 0.9560 - val_loss: 0.7053 - val_accuracy: 0.8000 - 118ms/epoch - 2ms/step\nEpoch 10/30\n63/63 - 0s - loss: 0.2595 - accuracy: 0.9640 - val_loss: 0.6916 - val_accuracy: 0.8000 - 121ms/epoch - 2ms/step\nEpoch 11/30\n63/63 - 0s - loss: 0.2313 - accuracy: 0.9720 - val_loss: 0.6898 - val_accuracy: 0.8000 - 118ms/epoch - 2ms/step\nEpoch 12/30\n63/63 - 0s - loss: 0.2083 - accuracy: 0.9680 - val_loss: 0.6702 - val_accuracy: 0.8000 - 120ms/epoch - 2ms/step\nEpoch 13/30\n63/63 - 0s - loss: 0.1892 - accuracy: 0.9800 - val_loss: 0.6641 - val_accuracy: 0.8000 - 117ms/epoch - 2ms/step\nEpoch 14/30\n63/63 - 0s - loss: 0.1705 - accuracy: 0.9840 - val_loss: 0.6615 - val_accuracy: 0.8000 - 119ms/epoch - 2ms/step\nEpoch 15/30\n63/63 - 0s - loss: 0.1560 - accuracy: 0.9880 - val_loss: 0.6612 - val_accuracy: 0.8000 - 120ms/epoch - 2ms/step\nEpoch 16/30\n63/63 - 0s - loss: 0.1445 - accuracy: 0.9880 - val_loss: 0.6594 - val_accuracy: 0.8000 - 121ms/epoch - 2ms/step\nEpoch 17/30\n63/63 - 0s - loss: 0.1300 - accuracy: 0.9920 - val_loss: 0.6416 - val_accuracy: 0.8000 - 117ms/epoch - 2ms/step\nEpoch 18/30\n63/63 - 0s - loss: 0.1202 - accuracy: 0.9920 - val_loss: 0.6438 - val_accuracy: 0.8000 - 120ms/epoch - 2ms/step\nEpoch 19/30\n63/63 - 0s - loss: 0.1111 - accuracy: 0.9960 - val_loss: 0.6485 - val_accuracy: 0.7667 - 118ms/epoch - 2ms/step\nEpoch 20/30\n63/63 - 0s - loss: 0.1024 - accuracy: 0.9960 - val_loss: 0.6403 - val_accuracy: 0.8000 - 116ms/epoch - 2ms/step\nEpoch 21/30\n63/63 - 0s - loss: 0.0952 - accuracy: 0.9960 - val_loss: 0.6489 - val_accuracy: 0.7667 - 120ms/epoch - 2ms/step\nEpoch 22/30\n63/63 - 0s - loss: 0.0881 - accuracy: 0.9960 - val_loss: 0.6365 - val_accuracy: 0.7667 - 117ms/epoch - 2ms/step\nEpoch 23/30\n63/63 - 0s - loss: 0.0823 - accuracy: 0.9960 - val_loss: 0.6413 - val_accuracy: 0.7667 - 118ms/epoch - 2ms/step\nEpoch 24/30\n63/63 - 0s - loss: 0.0771 - accuracy: 0.9960 - val_loss: 0.6415 - val_accuracy: 0.7667 - 118ms/epoch - 2ms/step\nEpoch 25/30\n63/63 - 0s - loss: 0.0718 - accuracy: 1.0000 - val_loss: 0.6426 - val_accuracy: 0.7667 - 120ms/epoch - 2ms/step\nEpoch 26/30\n63/63 - 0s - loss: 0.0672 - accuracy: 1.0000 - val_loss: 0.6439 - val_accuracy: 0.7667 - 120ms/epoch - 2ms/step\nEpoch 27/30\n63/63 - 0s - loss: 0.0631 - accuracy: 1.0000 - val_loss: 0.6340 - val_accuracy: 0.7667 - 117ms/epoch - 2ms/step\nEpoch 28/30\n63/63 - 0s - loss: 0.0594 - accuracy: 1.0000 - val_loss: 0.6379 - val_accuracy: 0.7667 - 118ms/epoch - 2ms/step\nEpoch 29/30\n63/63 - 0s - loss: 0.0560 - accuracy: 1.0000 - val_loss: 0.6386 - val_accuracy: 0.7667 - 121ms/epoch - 2ms/step\nEpoch 30/30\n63/63 - 0s - loss: 0.0527 - accuracy: 1.0000 - val_loss: 0.6411 - val_accuracy: 0.7667 - 116ms/epoch - 2ms/step\n</pre> In\u00a0[56]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.style.use(\"seaborn\")\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(9, 9))\n\nax1.plot(q_history.history[\"val_accuracy\"], \"-ob\", label=\"With quantum layer\")\nax1.plot(c_history.history[\"val_accuracy\"], \"-og\", label=\"Without quantum layer\")\nax1.set_ylabel(\"Accuracy\")\nax1.set_ylim([0, 1])\nax1.set_xlabel(\"Epoch\")\nax1.legend()\n\nax2.plot(q_history.history[\"val_loss\"], \"-ob\", label=\"With quantum layer\")\nax2.plot(c_history.history[\"val_loss\"], \"-og\", label=\"Without quantum layer\")\nax2.set_ylabel(\"Loss\")\nax2.set_ylim(top=2.5)\nax2.set_xlabel(\"Epoch\")\nax2.legend()\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  plt.style.use(\"seaborn\") fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(9, 9))  ax1.plot(q_history.history[\"val_accuracy\"], \"-ob\", label=\"With quantum layer\") ax1.plot(c_history.history[\"val_accuracy\"], \"-og\", label=\"Without quantum layer\") ax1.set_ylabel(\"Accuracy\") ax1.set_ylim([0, 1]) ax1.set_xlabel(\"Epoch\") ax1.legend()  ax2.plot(q_history.history[\"val_loss\"], \"-ob\", label=\"With quantum layer\") ax2.plot(c_history.history[\"val_loss\"], \"-og\", label=\"Without quantum layer\") ax2.set_ylabel(\"Loss\") ax2.set_ylim(top=2.5) ax2.set_xlabel(\"Epoch\") ax2.legend() plt.tight_layout() plt.show() <pre>/tmp/ipykernel_21206/925943430.py:3: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use(\"seaborn\")\n</pre> In\u00a0[85]: Copied! <pre>import numpy as np\nfrom timeit import default_timer as timer\nimport pennylane as qml\n\ndef quanv(image, circuit):\n\"\"\"Convolves the input image with many applications of the same quantum circuit.\"\"\"\n    out = np.zeros((14, 14, 4))\n    for j in range(0, 28, 2):\n        for k in range(0, 28, 2):\n            q_results = circuit(image[j:j+2, k:k+2, 0].flatten())\n            out[j // 2, k // 2] = q_results\n    return out\n\ndef q_process(images, circuit, device_name):\n    print(f\"Quantum pre-processing of images on {device_name} device:\")\n    q_images = []\n    for idx, img in enumerate(images):\n        print(f\"{idx + 1}/{len(images)}        \", end=\"\\r\")\n        q_images.append(quanv(img, circuit))\n    return np.array(q_images)\n\ndef create_circuit(dev, num_wires, num_layers):\n    rand_params = np.random.uniform(0, 2 * np.pi, (num_layers, num_wires))\n    \n    @qml.qnode(dev)\n    def circuit(phi):\n        for j, p in enumerate(phi):\n            qml.RY(np.pi * p, wires=j % num_wires)\n        qml.RandomLayers(rand_params, wires=list(range(num_wires)))\n        return [qml.expval(qml.PauliZ(j % num_wires)) for j in range(4)]\n    return circuit\n\ndef run_experiment(wires, layers, num_runs):\n    dev_gpu = qml.device('lightning.gpu', wires=wires)\n    dev_cpu = qml.device('lightning.qubit', wires=wires)\n    \n    circuit_cpu = create_circuit(dev_cpu, wires, layers)\n    circuit_gpu = create_circuit(dev_gpu, wires, layers)\n    \n    def time_process(process_func):\n        timings = []\n        for _ in range(num_runs):\n            start = timer()\n            process_func()\n            timings.append(timer() - start)\n        return np.mean(timings)\n    \n    cpu_time = time_process(lambda: q_process(train_images, circuit_cpu, \"lightning.qubit\"))\n    gpu_time = time_process(lambda: q_process(train_images, circuit_gpu, \"lightning.gpu\"))\n    \n    print(f\"Completed: Wires={wires}, Layers={layers}, CPU time={cpu_time:.4f}s, GPU time={gpu_time:.4f}s\")\n    return cpu_time, gpu_time\n\n# Parameters to test\nwires_range = [1, 2, 4, 5, 10, 15, 18]\nlayers_range = [3]\nnum_runs = 1\n\n# Dictionary to store timing results\ntiming_results = {\n    'cpu': np.zeros((len(wires_range), len(layers_range))),\n    'gpu': np.zeros((len(wires_range), len(layers_range)))\n}\n\n# Run simulations for each combination of parameters\nfor i, wires in enumerate(wires_range):\n    for j, layers in enumerate(layers_range):\n        cpu_time, gpu_time = run_experiment(wires, layers, num_runs)\n        timing_results['cpu'][i, j] = cpu_time\n        timing_results['gpu'][i, j] = gpu_time\n</pre> import numpy as np from timeit import default_timer as timer import pennylane as qml  def quanv(image, circuit):     \"\"\"Convolves the input image with many applications of the same quantum circuit.\"\"\"     out = np.zeros((14, 14, 4))     for j in range(0, 28, 2):         for k in range(0, 28, 2):             q_results = circuit(image[j:j+2, k:k+2, 0].flatten())             out[j // 2, k // 2] = q_results     return out  def q_process(images, circuit, device_name):     print(f\"Quantum pre-processing of images on {device_name} device:\")     q_images = []     for idx, img in enumerate(images):         print(f\"{idx + 1}/{len(images)}        \", end=\"\\r\")         q_images.append(quanv(img, circuit))     return np.array(q_images)  def create_circuit(dev, num_wires, num_layers):     rand_params = np.random.uniform(0, 2 * np.pi, (num_layers, num_wires))          @qml.qnode(dev)     def circuit(phi):         for j, p in enumerate(phi):             qml.RY(np.pi * p, wires=j % num_wires)         qml.RandomLayers(rand_params, wires=list(range(num_wires)))         return [qml.expval(qml.PauliZ(j % num_wires)) for j in range(4)]     return circuit  def run_experiment(wires, layers, num_runs):     dev_gpu = qml.device('lightning.gpu', wires=wires)     dev_cpu = qml.device('lightning.qubit', wires=wires)          circuit_cpu = create_circuit(dev_cpu, wires, layers)     circuit_gpu = create_circuit(dev_gpu, wires, layers)          def time_process(process_func):         timings = []         for _ in range(num_runs):             start = timer()             process_func()             timings.append(timer() - start)         return np.mean(timings)          cpu_time = time_process(lambda: q_process(train_images, circuit_cpu, \"lightning.qubit\"))     gpu_time = time_process(lambda: q_process(train_images, circuit_gpu, \"lightning.gpu\"))          print(f\"Completed: Wires={wires}, Layers={layers}, CPU time={cpu_time:.4f}s, GPU time={gpu_time:.4f}s\")     return cpu_time, gpu_time  # Parameters to test wires_range = [1, 2, 4, 5, 10, 15, 18] layers_range = [3] num_runs = 1  # Dictionary to store timing results timing_results = {     'cpu': np.zeros((len(wires_range), len(layers_range))),     'gpu': np.zeros((len(wires_range), len(layers_range))) }  # Run simulations for each combination of parameters for i, wires in enumerate(wires_range):     for j, layers in enumerate(layers_range):         cpu_time, gpu_time = run_experiment(wires, layers, num_runs)         timing_results['cpu'][i, j] = cpu_time         timing_results['gpu'][i, j] = gpu_time <pre>Quantum pre-processing of images on lightning.qubit device:\nQuantum pre-processing of images on lightning.gpu device:\nCompleted: Wires=1, Layers=3, CPU time=62.3967s, GPU time=99.5497s\nQuantum pre-processing of images on lightning.qubit device:\nQuantum pre-processing of images on lightning.gpu device:\nCompleted: Wires=2, Layers=3, CPU time=80.9831s, GPU time=140.1532s\nQuantum pre-processing of images on lightning.qubit device:\nQuantum pre-processing of images on lightning.gpu device:\nCompleted: Wires=4, Layers=3, CPU time=110.6707s, GPU time=185.9546s\nQuantum pre-processing of images on lightning.qubit device:\nQuantum pre-processing of images on lightning.gpu device:\nCompleted: Wires=5, Layers=3, CPU time=123.1236s, GPU time=197.4196s\nQuantum pre-processing of images on lightning.qubit device:\nQuantum pre-processing of images on lightning.gpu device:\nCompleted: Wires=10, Layers=3, CPU time=225.3025s, GPU time=278.5930s\nQuantum pre-processing of images on lightning.qubit device:\nQuantum pre-processing of images on lightning.gpu device:\nCompleted: Wires=15, Layers=3, CPU time=354.5317s, GPU time=351.1855s\nQuantum pre-processing of images on lightning.qubit device:\nQuantum pre-processing of images on lightning.gpu device:\nCompleted: Wires=18, Layers=3, CPU time=856.8203s, GPU time=379.5449s\n</pre> In\u00a0[86]: Copied! <pre># Enable inline plotting\n%matplotlib inline\n# Plotting the results for each layer separately\nfor j, layers in enumerate(layers_range):\n    fig, ax = plt.subplots(figsize=(12, 8))\n    \n    width = 0.35  # Width of the bars\n    x = np.arange(len(wires_range))  # X-axis positions\n\n    # Create bar plots for CPU and GPU side by side\n    ax.bar(x - width/2, timing_results['cpu'][:, j], width, label='CPU')\n    ax.bar(x + width/2, timing_results['gpu'][:, j], width, label='GPU', hatch='//')\n\n    # Formatting the plot\n    ax.set_xlabel('Number of Wires (Qubits)')\n    ax.set_ylabel('Average Time (seconds)')\n    ax.set_title(f'CPU vs (one)GPU Timing Results (Layers={layers})')\n    ax.set_xticks(x)\n    ax.set_xticklabels(wires_range)\n    ax.legend()\n\n    # Optionally, uncomment the following line for logarithmic scale\n    # ax.set_yscale('log')\n\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.show()\n</pre> # Enable inline plotting %matplotlib inline # Plotting the results for each layer separately for j, layers in enumerate(layers_range):     fig, ax = plt.subplots(figsize=(12, 8))          width = 0.35  # Width of the bars     x = np.arange(len(wires_range))  # X-axis positions      # Create bar plots for CPU and GPU side by side     ax.bar(x - width/2, timing_results['cpu'][:, j], width, label='CPU')     ax.bar(x + width/2, timing_results['gpu'][:, j], width, label='GPU', hatch='//')      # Formatting the plot     ax.set_xlabel('Number of Wires (Qubits)')     ax.set_ylabel('Average Time (seconds)')     ax.set_title(f'CPU vs (one)GPU Timing Results (Layers={layers})')     ax.set_xticks(x)     ax.set_xticklabels(wires_range)     ax.legend()      # Optionally, uncomment the following line for logarithmic scale     # ax.set_yscale('log')      plt.xticks(rotation=45)     plt.tight_layout()     plt.show() <p>For short circuits with few numbers of qubits, the overheads of running the GPU device (initialization, memory allocations, initial copies) can tend to dominate, but for simulations in the 15 qubits and above region, the GPU device shines! The above figure shows an ever-widening gap for random circuit evaluations with over an order-of-magnitude timing reduction for large simulations relative to multi-threaded CPU-based simulations (the gap is even bigger for single CPU simulations). We also expect to see the same behavior for deep quantum circuits, where the initial setup overhead is minimal compared to the gates count required for the simulation.</p> In\u00a0[58]: Copied! <pre>dev = qml.device(\"lightning.gpu\", wires = wires, mpi = True)\n</pre> dev = qml.device(\"lightning.gpu\", wires = wires, mpi = True) <p>With this, <code>lightning.gpu</code> will automatically distribute and initialize a complete state vector across multiple GPUs. Each GPU is assigned a subsystem and <code>mpi_buf_size (MiB)</code> of device memory shared as a data buffer to assist with the MPI communications for quantum gate calls.</p> In\u00a0[59]: Copied! <pre>from mpi4py import MPI\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom timeit import default_timer as timer\n\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n\n# Set number of runs for timing averaging\nnum_runs = 3\n\nprint(size)\n\n# Choose number of qubits (wires) and circuit layers\nn_wires = 20\nn_layers = 2\n\n# Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device\n# mpi=True to switch on distributed simulation\n# batch_obs=True to reduce the device memory demand for adjoint backpropagation\ndev = qml.device('lightning.gpu', wires=n_wires, mpi=True, batch_obs=True)\n\n# Create QNode of device and circuit\n@qml.qnode(dev, diff_method=\"adjoint\")\ndef circuit_adj(weights):\n    qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))\n    return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(n_wires)])\n\n# Set trainable parameters for calculating circuit Jacobian at the rank=0 process\nif rank == 0:\n    params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires))\nelse:\n    params = None\n\n# Broadcast the trainable parameters across MPI processes from rank=0 process\nparams = comm.bcast(params, root=0)\n\n# Run, calculate the quantum circuit Jacobian and average the timing results\ntiming = []\nfor t in range(num_runs):\n    start = timer()\n    jac = qml.jacobian(circuit_adj)(params)\n    end = timer()\n    timing.append(end - start)\n\n# MPI barrier to ensure all calculations are done\ncomm.Barrier()\n\nif rank == 0:\n    print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))\n</pre> from mpi4py import MPI import pennylane as qml from pennylane import numpy as np from timeit import default_timer as timer  comm = MPI.COMM_WORLD rank = comm.Get_rank() size = comm.Get_size()  # Set number of runs for timing averaging num_runs = 3  print(size)  # Choose number of qubits (wires) and circuit layers n_wires = 20 n_layers = 2  # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device # mpi=True to switch on distributed simulation # batch_obs=True to reduce the device memory demand for adjoint backpropagation dev = qml.device('lightning.gpu', wires=n_wires, mpi=True, batch_obs=True)  # Create QNode of device and circuit @qml.qnode(dev, diff_method=\"adjoint\") def circuit_adj(weights):     qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))     return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(n_wires)])  # Set trainable parameters for calculating circuit Jacobian at the rank=0 process if rank == 0:     params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires)) else:     params = None  # Broadcast the trainable parameters across MPI processes from rank=0 process params = comm.bcast(params, root=0)  # Run, calculate the quantum circuit Jacobian and average the timing results timing = [] for t in range(num_runs):     start = timer()     jac = qml.jacobian(circuit_adj)(params)     end = timer()     timing.append(end - start)  # MPI barrier to ensure all calculations are done comm.Barrier()  if rank == 0:     print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))   <pre>1\nnum_gpus:  1  wires:  20  layers  2  time:  0.6925500299936781\n</pre> <p>Using 4 GPU nodes (16 NVIDIA A100 40GB GPUs), this simulation can easily be scaled to up to 33 qubits (128 GB). For short circuits with fewer qubits, the overheads of MPI communication across GPUs/nodes may tend to dominate, but for simulations in the region of 28 qubits and above, the computation scales almost linearly!</p> In\u00a0[\u00a0]: Copied! <pre>from mpi4py import MPI\nimport pennylane as qml\nimport numpy as np\nfrom timeit import default_timer as timer\n\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n\n# Set number of runs for timing averaging\nnum_runs = 3\n\n# Choose number of qubits (wires) and circuit layers\nn_wires = 33\nn_layers = 2\n\n# Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device.\n# mpi=True to switch on distributed simulation\ndev = qml.device('lightning.gpu', wires=n_wires, mpi=True)\n\n# Set target wires for probability calculation\nprob_wires = range(n_wires)\n\n# Create QNode of device and circuit\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))\n    return qml.probs(wires=prob_wires)\n\n# Set trainable parameters for calculating circuit Jacobian at the rank=0 process\nif rank == 0:\n    params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires))\nelse:\n    params = None\n\n# Broadcast the trainable parameters across MPI processes from rank=0 process \nparams = comm.bcast(params, root=0)\n\n# Run, calculate the quantum circuit Jacobian and average the timing results\ntiming = []\nfor t in range(num_runs):\n    start = timer()\n    local_probs = circuit(params)\n    end = timer()\n    timing.append(end - start)\n\n# MPI barrier to ensure all calculations are done\ncomm.Barrier()\n\nif rank == 0:\n    print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))\n</pre> from mpi4py import MPI import pennylane as qml import numpy as np from timeit import default_timer as timer  comm = MPI.COMM_WORLD rank = comm.Get_rank() size = comm.Get_size()  # Set number of runs for timing averaging num_runs = 3  # Choose number of qubits (wires) and circuit layers n_wires = 33 n_layers = 2  # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device. # mpi=True to switch on distributed simulation dev = qml.device('lightning.gpu', wires=n_wires, mpi=True)  # Set target wires for probability calculation prob_wires = range(n_wires)  # Create QNode of device and circuit @qml.qnode(dev) def circuit(weights):     qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))     return qml.probs(wires=prob_wires)  # Set trainable parameters for calculating circuit Jacobian at the rank=0 process if rank == 0:     params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires)) else:     params = None  # Broadcast the trainable parameters across MPI processes from rank=0 process  params = comm.bcast(params, root=0)  # Run, calculate the quantum circuit Jacobian and average the timing results timing = [] for t in range(num_runs):     start = timer()     local_probs = circuit(params)     end = timer()     timing.append(end - start)  # MPI barrier to ensure all calculations are done comm.Barrier()  if rank == 0:     print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))   <p>Simulations of a 34-qubit system distributed across multiple GPUs demonstrate that computation accelerates with more GPUs, exhibiting super-linear scalability and maintaining parallel efficiency even when utilizing up to 128 GPUs.</p>"},{"location":"pennylane_final/#quantum-computing-using-pennylane-library","title":"Quantum Computing using PennyLane library\u00b6","text":""},{"location":"pennylane_final/#prerequisites","title":"Prerequisites\u00b6","text":"<ol> <li><p>Basic Python programming skills:</p> <ul> <li><p>Familiarity with Python syntax</p> </li> <li><p>Understanding of functions, loops, and conditional statements</p> </li> <li><p>Experience with common data types (lists, dictionaries, etc.)</p> </li> </ul> </li> <li><p>Basic mathematics:</p> <ul> <li><p>Comfort with high school level algebra</p> </li> <li><p>Familiarity with complex numbers (helpful but not required)</p> </li> </ul> </li> </ol> <p>No prior knowledge of quantum computing is required. This tutorial is designed to introduce quantum computing concepts from the ground up using PennyLane.</p>"},{"location":"pennylane_final/#table-of-contents","title":"Table of contents\u00b6","text":"<ol> <li><p>Introduction</p> </li> <li><p>PennyLane</p> </li> <li><p>Jupyter Kernel</p> </li> <li><p>Using PennyLane</p> <ol> <li><p>Quantum gates and circuits in PennyLane</p> </li> <li><p>Grovers Algorithm implementation</p> </li> <li><p>Quantum Teleportation</p> </li> </ol> </li> <li><p>PennyLane GPU device</p> <p>a. Single GPU Quantum Simulations</p> <p>b. Benchmark CPU vs GPU</p> <p>c. Distributed GPU with MPI</p> </li> <li><p>Conclusion</p> </li> </ol>"},{"location":"pennylane_final/#introduction-to-quantum-computing","title":"Introduction to quantum Computing\u00b6","text":""},{"location":"pennylane_final/#classical-vs-quantum-computing","title":"Classical vs Quantum Computing\u00b6","text":"<p>Classical computing uses bits (0s and 1s) to process information sequentially. Quantum computing uses qubits, which can exist in multiple states simultaneously, allowing for parallel processing. Think of classical computing as a linear path through a maze, while quantum computing explores all paths at once.</p>"},{"location":"pennylane_final/#qubits","title":"Qubits\u00b6","text":"<p>Qubits are the fundamental unit of quantum information. Unlike classical bits, which are either 0 or 1, qubits can be in a combination of both states. Imagine a coin spinning on a table - while it's spinning, it's neither heads nor tails, but a combination of both.</p>"},{"location":"pennylane_final/#superposition","title":"Superposition:\u00b6","text":"<p>Superposition is the ability of a qubit to be in multiple states at once. It's like having a box with a ball that can be in every possible position inside the box simultaneously until you open it to look.</p>"},{"location":"pennylane_final/#schrodingers-cat-metaphor","title":"Schr\u00f6dinger's Cat Metaphor\u00b6","text":"<p>This famous thought experiment illustrates superposition. Imagine a cat in a box with a device that may or may not have killed it. According to quantum mechanics, until we open the box, the cat is simultaneously alive and dead. This represents how a qubit can be in multiple states until measured.</p>"},{"location":"pennylane_final/#entanglement","title":"Entanglement:\u00b6","text":"<p>Entanglement occurs when qubits are connected in such a way that the state of one cannot be described independently of the other. It's like having two magical coins that always land on the same side, even when flipped far apart.</p>"},{"location":"pennylane_final/#quantum-gates","title":"Quantum Gates:\u00b6","text":"<p>Quantum gates are operations applied to qubits to manipulate their states. They're similar to logic gates in classical computing, but they can create and manipulate superposition and entanglement. Think of them as special lenses that can change the \"spin\" of our quantum coin in unique ways.</p>"},{"location":"pennylane_final/#why-using-quantum-computing","title":"Why using Quantum Computing?\u00b6","text":""},{"location":"pennylane_final/#potential-applications-of-quantum-computing","title":"Potential Applications of Quantum Computing\u00b6","text":""},{"location":"pennylane_final/#cryptography","title":"Cryptography\u00b6","text":"<p>Quantum computers could break many current encryption methods, but also enable ultra-secure quantum encryption. This could revolutionize data security and privacy.</p>"},{"location":"pennylane_final/#optimization","title":"Optimization\u00b6","text":"<p>Solving complex optimization problems in logistics, finance, and engineering. Quantum algorithms could find optimal solutions much faster than classical computers.</p>"},{"location":"pennylane_final/#material-science","title":"Material Science\u00b6","text":"<p>Simulating quantum systems to discover new materials with specific properties. This could lead to breakthroughs in battery technology, solar cells, and superconductors.</p>"},{"location":"pennylane_final/#drug-discovery","title":"Drug Discovery\u00b6","text":"<p>Modeling molecular interactions to accelerate drug development and potentially find cures for diseases that are currently intractable.</p>"},{"location":"pennylane_final/#financial-modeling","title":"Financial Modeling\u00b6","text":"<p>Improving portfolio optimization, risk analysis, and fraud detection in the financial sector.</p>"},{"location":"pennylane_final/#climate-modeling","title":"Climate Modeling\u00b6","text":"<p>Enhancing climate change predictions and helping to develop more effective mitigation strategies.</p>"},{"location":"pennylane_final/#real-world-examples-companies-exploring-quantum-computing","title":"Real-World Examples: Companies Exploring Quantum Computing\u00b6","text":""},{"location":"pennylane_final/#google","title":"Google\u00b6","text":"<ul> <li>Achieved \"quantum supremacy\" in 2019 with their 53-qubit Sycamore processor.</li> <li>Developing error-corrected quantum computers and quantum machine learning algorithms.</li> </ul>"},{"location":"pennylane_final/#ibm","title":"IBM\u00b6","text":"<ul> <li>Offers cloud-based quantum computing services through IBM Quantum Experience.</li> <li>Working on building larger quantum processors and developing quantum software tools.</li> </ul>"},{"location":"pennylane_final/#microsoft","title":"Microsoft\u00b6","text":"<ul> <li>Developing topological qubits for more stable quantum computations.</li> <li>Created Q#, a programming language for quantum computing.</li> </ul>"},{"location":"pennylane_final/#d-wave-systems","title":"D-Wave Systems\u00b6","text":"<ul> <li>Focuses on quantum annealing for optimization problems.</li> <li>Has sold quantum annealing systems to companies and research institutions.</li> </ul>"},{"location":"pennylane_final/#rigetti-computing","title":"Rigetti Computing\u00b6","text":"<ul> <li>Building hybrid quantum-classical computing systems.</li> <li>Offers cloud access to their quantum processors.</li> </ul>"},{"location":"pennylane_final/#ionq","title":"IonQ\u00b6","text":"<ul> <li>Developing trapped-ion quantum computers.</li> <li>Achieved high-fidelity operations on their quantum processors.</li> </ul> <p>These companies are pushing the boundaries of quantum computing, working to overcome current limitations and bring practical quantum applications to various industries.</p>"},{"location":"pennylane_final/#introduction-pennylane","title":"Introduction PennyLane\u00b6","text":""},{"location":"pennylane_final/#what-is-pennylane","title":"What is PennyLane?\u00b6","text":"<p>PennyLane is a cross-platform Python library for quantum computing, quantum machine learning, and quantum chemistry.</p> <p>It provides a unified approach to hybrid quantum-classical computation, allowing smooth integration of quantum hardware with classical machine learning libraries like PyTorch and TensorFlow.</p>"},{"location":"pennylane_final/#pennylane-vs-other-frameworks","title":"PennyLane vs other Frameworks\u00b6","text":"<p>Let's breakddown the main difference between PennyLane and some other popular frameworks:</p> Framework Focus Key Feature Backend PennyLane Quantum machine learning and variational algorithms Seamless integration with classical ML libraries Multiple (IBM, Google, Amazon) Qiskit (IBM) General-purpose quantum computing Comprehensive toolset for IBM quantum hardware Primarily IBM, can integrate others Cirq (Google) Near-term quantum algorithms and hardware Low-level control over qubit placement and timing Google's hardware, usable with others Q# (Microsoft) High-level quantum programming Domain-specific language for quantum computing Microsoft's simulators and future hardware Amazon Braket Access to multiple quantum hardware providers Unified interface for different quantum processors Multiple (D-Wave, IonQ, Rigetti) Rigetti Forest (pyQuil) Quantum programming for Rigetti hardware Quil assembly language for quantum instructions Rigetti processors and simulators Xanadu Strawberry Fields Continuous-variable quantum computing Photonic quantum computing simulations Xanadu's photonic hardware and simulators D-Wave Ocean Quantum annealing and hybrid solvers Optimization problems and sampling applications D-Wave's quantum annealers QuTiP Dynamics of open quantum systems Comprehensive library for quantum optics Classical simulation of quantum systems ProjectQ High-level quantum programming Compiler framework for quantum circuits Multiple (IBM and classical simulators) TensorFlow Quantum Quantum machine learning research Integration with TensorFlow ecosystem Cirq-based simulators and Google hardware <p>Key Differences</p> <p>Hardware Access: Varies from specialized (D-Wave, Rigetti) to multi-platform (PennyLane, Amazon Braket) Abstraction Level: Ranges from low-level (Cirq) to high-level (Q#) Application Focus: General-purpose (Qiskit) vs. specialized (Strawberry Fields for photonics) Integration: Some focus on classical-quantum integration (PennyLane, TensorFlow Quantum) more than others1. PennyLane</p>"},{"location":"pennylane_final/#setting-our-jupyternotebook","title":"Setting our Jupyternotebook\u00b6","text":""},{"location":"pennylane_final/#pennylane-kernel","title":"PennyLane kernel\u00b6","text":""},{"location":"pennylane_final/#reload-environment","title":"Reload environment\u00b6","text":""},{"location":"pennylane_final/#inline-matplotlib-for-plots-in-jupyter","title":"Inline matplotlib for plots in Jupyter\u00b6","text":""},{"location":"pennylane_final/#import-packages-to-be-used","title":"Import packages to be used\u00b6","text":""},{"location":"pennylane_final/#using-pennylane","title":"Using PennyLane\u00b6","text":""},{"location":"pennylane_final/#defining-a-quantum-device-and-circuit","title":"Defining a Quantum Device and Circuit\u00b6","text":""},{"location":"pennylane_final/#device","title":"Device\u00b6","text":"<p>The first step in <code>PennyLane</code> is to always initialize a device to run on.</p>"},{"location":"pennylane_final/#definition","title":"Definition\u00b6","text":"<p>Any computational object that can apply quantum operations and return a measurement value is called a quantum device.</p> <p>In PennyLane, a device could be a hardware device (real Quantum Computer), or a software simulator (such as our high performance simulator, Qiskit ...).</p> <p>NOTE: Devices are loaded in PennyLane via the function <code>device()</code>.</p> <p>PennyLane supports devices using both the qubit model of quantum computation and devices using the Continuous Variable (CV) model of quantum computation. In fact, even a hybrid computation containing both qubit and CV quantum nodes is possible;</p> <p>We will only see the qubit model with the <code>'default.qubit', 'lightning.qubit', 'lightning.gpu'</code> device provided by PennyLane.</p>"},{"location":"pennylane_final/#qnode","title":"QNode\u00b6","text":"<p>Now that we have initialized our device, we can begin to construct a quantum node (or QNode).</p>"},{"location":"pennylane_final/#definition","title":"Definition\u00b6","text":"<p>QNodes are an abstract encapsulation of a quantum function, described by a quantum circuit. QNodes are bound to a particular quantum device, which is used to evaluate expectation and variance values of this circuit.</p> <p>QNodes can be constructed via the QNode class, or by using the provided qnode decorator.</p> <p>First, we need to define the quantum function that will be evaluated in the QNode:</p>"},{"location":"pennylane_final/#quantum-gatescircuits-examples","title":"Quantum gates/circuits examples\u00b6","text":"<p>Let's setup our device as follow:</p>"},{"location":"pennylane_final/#pauli-gates-x-y-z","title":"PAULI GATES X, Y, Z\u00b6","text":"<p>The Pauli gates are single-qubit gates that perform rotations about the respective axes of the Bloch sphere.</p> <p>The Bloch sphere is a geometric representation of the pure state of a qubit on a unit sphere in three-dimensional space and is used to visualize and describe the quantum state of the qubit. Quantum gates and operations on a qubit can be visualized as rotations of the state vector on the Bloch sphere.</p>"},{"location":"pennylane_final/#hadamard-gate","title":"Hadamard gate\u00b6","text":"<p>The Hadamard gate creates a superposition state from a computational basis state.</p>"},{"location":"pennylane_final/#controlled-not-gate-cnot","title":"Controlled-NOT Gate (CNOT)\u00b6","text":"<p>The Controlled-NOT (CNOT) gate is a two-qubit gate that flips the state of the second qubit (target) if the first qubit (control) is in the \u22231\u27e9 state.</p>"},{"location":"pennylane_final/#rotation-gates-rx-ry-rz","title":"Rotation gates RX, RY, RZ\u00b6","text":"<p>Rotation gates rotate the state of a qubit around a specific axis of the Bloch sphere by a given angle.</p>"},{"location":"pennylane_final/#swap-gate","title":"Swap gate\u00b6","text":"<p>The SWAP gate swaps the states of two qubits.</p>"},{"location":"pennylane_final/#implement-a-2-qubit-quantum-fourier-transform","title":"Implement a 2-qubit Quantum Fourier Transform.\u00b6","text":""},{"location":"pennylane_final/#grovers-algorithm","title":"Grover's Algorithm\u00b6","text":"<p>Grover's algorithm is an oracle-based quantum algorithm, proposed by Lov Grover. In the original description, the author approaches the following problem: suppose that we are searching for a specific phone number in a randomly-ordered catalogue containing $N$ entries. To find such a number with a probability of $\\frac{1}{2}$, a classical algorithm will need to check the list on average $\\frac{N}{2}$ times.</p> <p>In other words, the problem is defined by searching for an item on a list with $N$ items given an Oracle access function $f(x)$. This function has the defining property that $f(x) = 1$ if $x$ is the item we are looking for, and $f(x) = 0$ otherwise. The solution to this black-box search problem is proposed as a quantum algorithm that performs $O(\\sqrt{N})$ oracular queries to the list with a high probability of finding the answer, whereas any classical algorithm would require $O(N)$ queries.</p> <p>In this tutorial, we are going to implement a search for an n-bit string item using a quantum circuit based on Grover's algorithm.</p> <p>The algorithm can be broken down into the following steps:</p> <ol> <li>Prepare the initial state</li> <li>Implement the oracle</li> <li>Apply the Grover diffusion operator</li> <li>Repeat steps 2 and 3 approximately $\\frac{\\pi}{4}\\sqrt{N}$ times</li> <li>Measure</li> </ol> <p>Let's import the usual PennyLane and Numpy libraries to load the necessary functions:</p>"},{"location":"pennylane_final/#preparing-the-initial-state","title":"Preparing the Initial State\u00b6","text":"<p>To perform the search, we are going to create an n-dimensional system, which has $N = 2^n$ computational basis states, represented via $N$ binary numbers. More specifically, bit strings with length $n$, labelled as $x_0,x_2,\\cdots, x_{N-1}$. We initialize the system in the uniform superposition over all states, i.e., the amplitudes associated with each of the $N$ basis states are equal:</p> <p>$$|s\\rangle ={\\frac {1}{\\sqrt {N}}}\\sum _{x=0}^{N-1}|x\\rangle .$$</p> <p>This can be achieved by applying a Hadamard gate to all the wires. We can inspect the circuit using <code>Snapshot</code> to see how the states change on each step. Let us check the probability of finding a state in the computational basis for a 2-qubit circuit, writing the following functions and QNodes:</p>"},{"location":"pennylane_final/#the-oracle-and-grovers-diffusion-operator","title":"The Oracle and Grover's diffusion operator\u00b6","text":"<p>Let's assume for now that only one index satisfies $f(x) = 1$. We are going to call this index $\\omega$. To access $f(x)$ with an Oracle, we can formulate a unitary operator such that</p> <p>$$\\begin{aligned} \\begin{cases} U_{\\omega }|x\\rangle =-|x\\rangle &amp;{\\text{for }}x=\\omega {\\text{, that is, }}f(x)=1,\\\\U_{\\omega }|x\\rangle =|x\\rangle &amp;{\\text{for }}x\\neq \\omega {\\text{, that is, }}f(x)=0, \\end{cases} \\end{aligned}$$</p> <p>where and $U_\\omega$ acts by flipping the phase of the solution state while keeping the remaining states untouched. In other words, the unitary $U_\\omega$ can be seen as a reflection around the set of orthogonal states to $\\vert \\omega \\rangle$, written as</p> <p>$$U_\\omega = \\mathbb{I} - 2\\vert \\omega \\rangle \\langle \\omega \\vert.$$</p> <p>This can be easily implemented with <code>FlipSign</code>, which takes a binary array and flips the sign of the corresponding state.</p> <p>Let us take a look at an example. If we pass the array <code>[0,0]</code>, the sign of the state $\\vert 00 \\rangle = \\begin{bmatrix} 1 \\\\0 \\\\0 \\\\0 \\end{bmatrix}$ will flip:</p>"},{"location":"pennylane_final/#searching-for-more-items-in-a-bigger-list","title":"Searching for more items in a bigger list\u00b6","text":"<p>Now, let us consider the generalized problem with large $N$, accepting $M$ solutions, with $1 \\leq M \\leq N$. In this case, the optimal number of Grover iterations to find the solution is given by $r \\approx \\left \\lceil \\frac{\\pi}{4} \\sqrt{\\frac{N}{M}} \\right \\rceil$.</p> <p>For more qubits, we can use the same function for the Oracle to mark the desired states, and the diffusion operator takes a more general form:</p> <p>which is easily implemented using <code>GroverOperator</code>.</p> <p>Finally, we have all the tools to build the circuit for Grover's algorithm, as we can see in the code below. For simplicity, we are going to search for the states $\\vert 0\\rangle ^{\\otimes n}$ and $\\vert 1\\rangle ^{\\otimes n}$, where $n = \\log_2 N$ is the number of qubits.</p>"},{"location":"pennylane_final/#conclusion","title":"Conclusion\u00b6","text":"<p>In conclusion, we have learned the basic steps of Grover's algorithm and how to implement it to search $M$ items in a list of size $N$ with high probability.</p> <p>Grover's algorithm in principle can be used to speed up more sophisticated computation, for instance, when used as a subroutine for problems that require extensive search and is the basis of a whole family of algorithms, such as the amplitude amplification technique.</p>"},{"location":"pennylane_final/#application-of-grovers-algorithm","title":"Application of Grover's algorithm\u00b6","text":""},{"location":"pennylane_final/#the-inheritance-problem","title":"The inheritance problem\u00b6","text":"<p>Suppose we have a set of 4 properties we want to share between two siblings as an inheritance. Let's say we ant to find properties combination to give each siblings that would be <code>FAIR</code>. In this example it is simple to check if a combination is <code>FAIR</code> (equal in this case or not), as to say to have an Oracle function.</p> <p>Let's suppose the following list of properties prices to share between the two siblings in which we want to have to partition into two equal sets.</p>"},{"location":"pennylane_final/#quantum-teleportation","title":"Quantum Teleportation\u00b6","text":"<p>This section walks through a popular quantum information technique known as quantum teleportation. While teleportation has been thought of as the stuff of sci-fi legend, we are going to prove that it is actually already possible today! The technique leverages many foundational principles of quantum computing, and it has lots of useful applications across the entire field. These principles include (but are not limited to): the no-cloning theorem, quantum entanglement, and the principle of deferred measurement. Let\u2019s dive in!</p>"},{"location":"pennylane_final/#goal-transferring-quantum-information","title":"Goal: Transferring Quantum Information\u00b6","text":"<p>Suppose there are two researchers named Alice and Bob, and Alice wants to send her quantum state to Bob. The quantum teleportation protocol enables Alice to do exactly this in a very elegant manner, and it can be described in four steps:</p> <p>1. State preparation: Alice initializes her qubit to the state she wishes to teleport.</p> <p>2. Shared entanglement: A Bell state is created and distributed to Alice and Bob (one qubit each).</p> <p>3. Change of basis: Alice converts her two qubits from the Bell basis to the computational basis.</p> <p>4. Measurement: Alice measures her two qubits, then tells Bob how to convert his qubit to obtain the desired state. Note that it is only quantum information being teleported, and not a physical particle.</p> <p>An overview of the protocol can be seen here:</p>"},{"location":"pennylane_final/#problem-the-no-cloning-theorem","title":"Problem: The No-Cloning Theorem\u00b6","text":"<p>You might be wondering why we need to teleport a state at all. Can't Alice just make a copy of it and send the copy to Bob? It turns out that copying arbitrary states is prohibited, which you can understand using something called the no-cloning theorem. The proof is surprisingly straightforward. Suppose we would like to design a circuit (unitary transformation) $U$ that can perform the following action:</p> <p>$$\\begin{aligned} \\begin{align*} U(\\vert \\psi\\rangle \\otimes \\vert s\\rangle ) &amp;= \\vert \\psi\\rangle \\otimes \\vert \\psi\\rangle, \\\\ U(\\vert \\varphi\\rangle \\otimes \\vert s\\rangle ) &amp;= \\vert \\varphi \\rangle \\otimes \\vert \\varphi \\rangle, \\end{align*} \\end{aligned}$$</p> <p>where $\\vert \\psi\\rangle$ and $\\vert \\varphi\\rangle$ are arbitrary, normalized single-qubit states, and $\\vert s \\rangle$ is some arbitrary, normalized starting state. We will now prove that no such $U$ exists!</p> <p>First, let's take the inner product of the left-hand sides of the two equations:</p> <p>$$(\\langle \\psi \\vert \\otimes \\langle s \\vert) U^\\dagger U(\\vert \\varphi\\rangle \\otimes \\vert s\\rangle ) = \\langle \\psi \\vert \\varphi\\rangle \\  \\langle s \\vert s\\rangle$$</p> <p>Since $\\langle s \\vert s\\rangle$ equals 1, this evaluates to $\\langle \\psi \\vert \\varphi \\rangle$. Next, we compare the inner product of the right-hand sides of the two equations: $(\\langle \\psi \\vert \\varphi \\rangle)^2$. These inner products must be equal, and they are only equal if they are a value that squares to itself. The only valid values for the inner product then are 1 and 0. But if the inner product is 1, the states are the same; on the other hand, if the inner product is 0, the states are orthogonal. Therefore, we can't clone arbitrary states!</p>"},{"location":"pennylane_final/#solution-quantum-teleportation","title":"Solution: Quantum Teleportation\u00b6","text":"<p>We will now walk through how to share quantum information without cloning it, one step at a time.</p>"},{"location":"pennylane_final/#i-state-preparation","title":"I. State preparation\u00b6","text":"<p>Teleportation involves three qubits. Two of them are held by Alice, and the third by Bob. We'll denote their states using subscripts:</p> <ol> <li>$\\vert\\cdot\\rangle_S$, Alice's first qubit that she will prepare in some arbitrary state</li> <li>$\\vert\\cdot\\rangle_A$, Alice's auxiliary (or \"ancilla\") qubit that she will entangle with Bob's qubit for communication purposes</li> <li>$\\vert \\cdot\\rangle_B$, Bob's qubit that will receive the teleported state</li> </ol> <p>Together, their starting state is:</p> <p>$$\\vert 0\\rangle_S \\vert 0\\rangle_A \\vert 0\\rangle_B.$$</p> <p>The first thing Alice does is prepare her first qubit in whichever state $\\vert \\psi\\rangle$ that she'd like to send to Bob so that their combined state becomes:</p> <p>$$\\vert \\psi\\rangle_S \\vert 0\\rangle_A \\vert 0\\rangle_B.$$</p> <p>We can use the following quantum function to do the state preparation step:</p>"},{"location":"pennylane_final/#ii-shared-entanglement","title":"II. Shared entanglement\u00b6","text":"<p>The reason why teleportation works is the use of an entangled state as a shared resource between Alice and Bob. You can imagine some process that generates a pair of entangled qubits, and sends one qubit to each party. For simplicity (and simulation!), we will represent the entanglement process as part of our circuit.</p> <p>Entangling the qubits $A$ and $B$ leads to the combined state:</p> <p>$$\\frac{1}{\\sqrt{2}}\\left( \\vert \\psi\\rangle_S \\vert 0\\rangle_A \\vert 0\\rangle_B + \\vert \\psi\\rangle_S \\vert 1\\rangle_A \\vert 1\\rangle_B \\right)\\tag{1}$$</p> <p>The $AB$ subsystem is now in what is known as a Bell state. There are four maximally entangled two-qubit Bell states, and they form the Bell basis:</p> <p>$$\\begin{aligned} \\begin{align*} \\vert \\psi_+\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 00\\rangle + \\vert 11\\rangle \\right), \\\\ \\vert \\psi_-\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 00\\rangle - \\vert 11\\rangle \\right), \\\\ \\vert \\phi_+\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 01\\rangle + \\vert 10\\rangle \\right), \\\\ \\vert \\phi_-\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 01\\rangle - \\vert 10\\rangle \\right). \\end{align*} \\end{aligned}$$</p> <p>In our experiment, because $AB$ started in the $\\vert 00\\rangle$ state, we create the $\\vert \\psi_+\\rangle$ Bell state as is shown in equation (1).</p>"},{"location":"pennylane_final/#iii-change-of-basis","title":"III. Change of basis\u00b6","text":"<p>This is where things get tricky, but also very interesting. The third step of the protocol is to apply a CNOT and a Hadamard to the first two qubits. This is done prior to the measurements, and labelled \"change of basis\". But what basis is this? Notice how these two gates are the opposite of what we do to create a Bell state. If we run them in the opposite direction, we transform the basis back to the computational one, and simulate a measurement in the Bell basis.</p> <p>After the basis transform, if we observe the first two qubits to be in the state $\\vert 00\\rangle$, this would correspond to the outcome $\\vert \\psi_+\\rangle$ in the Bell basis, $\\vert 11\\rangle$ would correspond to $\\vert \\phi_-\\rangle$, etc. Let's perform this change of basis, one step at a time.</p> <p>Suppose we write our initial state $\\vert \\psi\\rangle$ as $\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle$, with $\\alpha$ and $\\beta$ being complex coefficients. Expanding out the terms from (1), we obtain:</p> <p>$$\\frac{1}{\\sqrt{2}} ( \\alpha\\vert 000\\rangle + \\beta\\vert 100\\rangle + \\alpha \\vert 011\\rangle + \\beta\\vert 111\\rangle )$$</p> <p>Now let's apply a CNOT between Alice's two qubits:</p> <p>$$\\frac{1}{\\sqrt{2}} ( \\alpha\\vert 000\\rangle + \\beta\\vert 110\\rangle + \\alpha \\vert 011\\rangle + \\beta\\vert 101\\rangle )$$</p> <p>And then a Hadamard on her first qubit:</p> <p>$$\\frac{1}{2} ( \\alpha \\vert 000\\rangle + \\alpha\\vert 100\\rangle + \\beta\\vert 010\\rangle - \\beta\\vert 110\\rangle + \\alpha \\vert 011\\rangle + \\alpha \\vert 111 \\rangle + \\beta\\vert 001\\rangle - \\beta\\vert 101 \\rangle ).$$</p> <p>Now we need to do some rearranging. We group the terms based on the first two qubits:</p> <p>$$\\frac{1}{2} \\vert 00\\rangle(\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 01\\rangle (\\beta\\vert 0\\rangle + \\alpha\\vert 1\\rangle) + \\frac{1}{2}\\vert 10\\rangle (\\alpha\\vert 0\\rangle - \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 11\\rangle (-\\beta\\vert 0\\rangle + \\alpha\\vert 1\\rangle).\\tag{2}$$</p>"},{"location":"pennylane_final/#iv-measurement","title":"IV. Measurement\u00b6","text":"<p>The last step of the protocol involves Alice performing a measurement on her qubits, and telling Bob to perform some operations depending on what she measured. But why exactly do we need to do this? In the previous step, we already performed a basis rotation back to the computational basis, so shouldn't we be good to go? Not quite, but almost!</p> <p>Let's take another look at equation (2). If Alice measures her two qubits in the computational basis, she is equally likely to obtain any of the four possible outcomes. If she observes the first two qubits in the state $\\vert 00 \\rangle$, she would immediately know that Bob's qubit was in the state $\\alpha \\vert 0 \\rangle + \\beta \\vert 1 \\rangle$, which is precisely the state we are trying to teleport!</p> <p>If instead she observed the qubits in state $\\vert 01\\rangle$, she'd still know what state Bob has, but it's a little off from the original state. In particular, we have:</p> <p>$$\\beta \\vert 0 \\rangle + \\alpha \\vert 1 \\rangle = X \\vert \\psi \\rangle.$$</p> <p>After obtaining these results, Alice could tell Bob to simply apply an X gate to his qubit to recover the original state. Similarly, if she obtained $\\vert 10\\rangle$, she would tell him to apply a Z gate.</p> <p>In the \"traditional\" version of quantum teleportation, this is, in fact, exactly what happens. Alice would call up Bob on the phone, tell him which state she observed, and then he would be able to apply an appropriate correction. In this situation, measurements are happening partway through the protocol, and the results would be used to control the application of future quantum gates. This is known as mid-circuit measurement, and such mid-circuit measurements are expressed in PennyLane using <code>qml.measure &lt;pennylane.measure&gt;</code>{.interpreted-text role=\"func\"}. Mid-circuit measurement results can be used to control operations, and this is expressed in PennyLane using <code>qml.cond &lt;pennylane.cond&gt;</code>{.interpreted-text role=\"func\"}.</p>"},{"location":"pennylane_final/#conclusion","title":"Conclusion\u00b6","text":"<p>Let's recap the concepts we've just seen. First, we established that quantum states cannot be arbitrarily copied due to the no-cloning theorem. Then, we learned about quantum entanglement. Once Alice and Bob shared an entangled pair of qubits, Alice performed a change of basis from the Bell basis to the computational basis. Finally, using the principle of deferred measurement when needed, Alice measured her two qubits and informed Bob on how to rotate his qubit into the desired state.</p> <p>Just like that, Alice and Bob performed quantum teleportation, and with a fairly small circuit! Some of you may now be thinking that teleportation is impossible, and you would be in good company if so. Einstein himself referred to the non-local nature of entanglement as \"spooky action at a distance\", but we can all rest easy: due to the need for classical communication from Alice to Bob, quantum states (in other words, information) still cannot be teleported faster than the speed of light. Don't let that take away from the importance of quantum teleportation! This protocol is a critical tool in quantum information processing, and now it is a tool that you wield.</p>"},{"location":"pennylane_final/#quantum-simulations-using-lightninggpu-with-nvidia-cuquantum-sdk","title":"Quantum simulations using <code>lightning.gpu</code> with NVIDIA cuQuantum SDK\u00b6","text":"<p>PennyLane supports GPU simulation through the <code>lightning.gpu</code> simulator device, which offloads quantum gate calls to the NVIDIA cuQuantum SDK.</p>"},{"location":"pennylane_final/#benefits","title":"Benefits\u00b6","text":"<p>GPUs are highly effective for workloads that massively depend on linear algebra due to their greater floating-point processing capabilities. In classical machine learning, especially deep learning, GPUs significantly accelerate training compared to CPUs. While GPUs generally have less on-device memory than CPU nodes, they offer high memory bandwidth and support a large number of concurrent threads. This makes them particularly well-suited for memory-bound operations like vector-vector products and vector scaling.</p> <p>Additionally, GPUs have optimized implementations of fundamental mathematical operations which make them a perfect match in compute-bound tasks such as dense matrix-matrix multiplications. Since quantum mechanics is frequently expressed using linear algebra and complex numbers, these GPU strengths can be harnessed to efficiently simulate quantum circuits.</p>"},{"location":"pennylane_final/#the-lightning-gpu-simulator-device","title":"The <code>lightning-gpu</code> simulator device\u00b6","text":"<p><code>lightning.gpu</code> offloads quantum gate calls to <code>Nvidia's cuQuantum cuStateVec</code> library kernels and functions, extending the work from <code>lightning.qubit</code> to capture and manipulate the Numpy data buffer in-place for direct support of machine-learning frameworks like TensorFlow, PyTorch, and JAX. The state-vector memory buffer is copied from NumPy to the GPU device, where all GPU-implemented functions are called to perform the required manipulations. Unsupported gate kernels are CPU-generated, transferred to the GPU, and cached for later reuse. Expectation values are evaluated directly on the GPU, and the state-vector is returned to a NumPy-compatible array on the host machine for easy manipulation by the end-user.</p>"},{"location":"pennylane_final/#meluxina-gpu-module","title":"MeluXina GPU module\u00b6","text":"<p>We have 200 nodes on MeluXina GPU featuring 2 AMD Rome CPUs (32 cores @ 2.35 GHz - 128HT cores total) and 4 NVIDIA A100-40 GPUs per node.</p> <p>The A100 GPU based on the Ampere GPU, offers significant improvements in performance and efficiency for both AI training and inference tasks. While not specifically designed for quantum computing simulations, the A100's massive parallel processing capabilities and high memory bandwidth make it well-suited for certain quantum computing tasks, particularly those involving tensor network calculations or quantum circuit simulations.</p>"},{"location":"pennylane_final/#quanvolutional-neural-networks","title":"Quanvolutional Neural Networks\u00b6","text":"<p>As a demonstration, we implement the Quanvolutional Neural Network, a quantum machine learning model and compare the run-times for lightning.qubit and lightning.gpu but allowing the lightning.qubit threading support to take full advantage of the available CPU. The circuit below evaluates the Jacobian of a strongly entangling layered circuit, and was run on an NVIDIA A100, comparing an A100 40GB GPU to an AMD Epyc 7H12 CPU:</p>"},{"location":"pennylane_final/#classical-convolution","title":"Classical convolution\u00b6","text":"<p>The convolutional neural network (CNN) is a standard model in classical machine learning which is particularly suitable for processing images. The model is based on the idea of a convolution layer where, instead of processing the full input data with a global function, a local convolution is applied.</p> <p>If the input is an image, small local regions are sequentially processed with the same kernel. The results obtained for each region are usually associated to different channels of a single output pixel. The union of all the output pixels produces a new image-like object, which can be further processed by additional layers.</p> <p>One can also extend the same idea to the context of quantum variational circuits.</p> <p>As described in the figure above:</p> <ol> <li><p>A small region of the input image, in our example a <code>2\u00d72</code> square, is embedded into a quantum circuit. This is achieved with parametrized rotations applied to the qubits initialized in the ground state.</p> </li> <li><p>A quantum computation, associated to a <code>unitary U</code>, is performed on the system. The unitary could be generated by a variational quantum circuit or, more simply, by a random circuit.</p> </li> <li><p>The quantum system is finally measured, obtaining a list of classical expectation values. The measurement results could also be classically post-processed, but, for simplicity, we directly use the raw expectation values.</p> </li> <li><p>Analogously to a classical convolution layer, each expectation value is mapped to a different channel of a single output pixel.</p> </li> <li><p>Iterating the same procedure over different regions, one can scan the full input image, producing an output object which will be structured as a multi-channel image.</p> </li> <li><p>The quantum convolution can be followed by further quantum layers or by classical layers.</p> </li> </ol>"},{"location":"pennylane_final/#loading-of-the-mnist-dataset","title":"Loading of the MNIST dataset\u00b6","text":"<p>We import the MNIST dataset from Keras. To speedup the evaluation of this demo we use only a small number of training and test images. Obviously, better results are achievable when using the full dataset.</p>"},{"location":"pennylane_final/#quantum-circuit-as-a-convolution-kernel","title":"Quantum circuit as a convolution kernel\u00b6","text":"<p>We follow the scheme described in the introduction and represented in the figure at the top of this demo.</p> <p>We initialize a PennyLane default.qubit device, simulating a system of 4 qubits. The associated qnode represents the quantum circuit consisting of:</p> <ol> <li><p>an embedding layer of local $R_y$ rotations (with angles scaled by a factor of $\u03c0$);</p> </li> <li><p>a random circuit of <code>n_layers</code>;</p> </li> <li><p>a final measurement in the computational basis, estimating 4 expectation values.</p> </li> </ol>"},{"location":"pennylane_final/#note","title":"Note:\u00b6","text":"<p>This process halves the resolution of the input image. In the standard language of CNN, this would correspond to a convolution with a $2\u00d72$ kernel and a stride equal to $2$.</p>"},{"location":"pennylane_final/#quantum-pre-processing-of-the-dataset","title":"Quantum pre-processing of the dataset\u00b6","text":"<p>Since we are not going to train the quantum convolution layer, it is more efficient to apply it as a \u201cpre-processing\u201d layer to all the images of our dataset. Later an entirely classical model will be directly trained and tested on the pre-processed dataset, avoiding unnecessary repetitions of quantum computations.</p> <p>The pre-processed images will be saved in the folder <code>SAVE_PATH</code>. Once saved, they can be directly loaded by setting <code>PREPROCESS = False</code>, otherwise the quantum convolution is evaluated at each run of the code.</p>"},{"location":"pennylane_final/#hybrid-quantum-classical-model","title":"Hybrid quantum-classical model\u00b6","text":"<p>After the application of the quantum convolution layer we feed the resulting features into a classical neural network that will be trained to classify the $10$ different digits of the MNIST dataset.</p> <p>We use a very simple model: just a fully connected layer with 10 output nodes with a final softmax activation function.</p> <p>The model is compiled with a stochastic-gradient-descent optimizer, and a cross-entropy loss function.</p>"},{"location":"pennylane_final/#training","title":"Training\u00b6","text":"<p>We first initialize an instance of the model, then we train and validate it with the dataset that has been already pre-processed by a quantum convolution.</p>"},{"location":"pennylane_final/#result","title":"Result\u00b6","text":"<p>We can finally plot the test accuracy and the test loss with respect to the number of training epochs.</p>"},{"location":"pennylane_final/#distributing-quantum-simulations-using-lightninggpu-with-nvidia-cuquantum","title":"Distributing quantum simulations using <code>lightning.gpu</code> with NVIDIA cuQuantum\u00b6","text":"<p>PennyLane supports distributed state vector simulations with the <code>lightning.gpu</code> simulator device , which offloads quantum gate calls to cuStateVec, and other distributed operations to Message Passing Interface (MPI).</p> <p>By adding a few addtional arguments when constructing a <code>lightning.gpu</code> device, a distributed simulation can be lauched and optimized easily, leading to better performance.</p>"},{"location":"pennylane_final/#background","title":"Background\u00b6","text":"<p>Simulating quantum systems is highly resource-intensive. State-vector simulation remains the preferred method for many quantum circuit workloads. However, a major limitation is the exponential growth in memory requirements as the number of qubits increases. On a desktop computer, simulations typically max out at around 30 qubits (16 GB), and adding just a few more can exceed the memory capacity of a single high-performance computing (HPC) node. Memory management is even more crucial when using graphics processing units (GPUs). To leverage the performance advantages of GPUs, it's beneficial to use multiple GPUs in tandem to store and operate on a single state vector.</p> <p>Simulating quantum systems requires storing the state vector, which grows exponentially with the number of qubits <code>n</code>. Each additional qubit doubles the size of the state vector, leading to significant memory demands. In double-precision calculations, storing the state vector of an $n-qubit$ system requires $2^n \\times 2^4$ bytes of memory. This exponential growth quickly exceeds the memory capacity of single GPUs, which typically max out at 80 GB. For instance, simulating a 32-qubit system requires about 68.7 GB of memory just for the state vector. This is almost double our A100 capacity. To simulate systems larger than 30 qubits (on our A100), it's necessary to distribute the state vector across multiple GPUs working in tandem, as a single GPU cannot handle the memory requirements alone.</p>"},{"location":"pennylane_final/#pennylane-gpumpi-support","title":"PennyLane GPU/MPI support\u00b6","text":"<p>Enabling distributed state vector simulation support is straightforward: just include the <code>mpi=True</code> argument when creating a <code>lightning.gpu</code> device:</p>"},{"location":"pennylane_final/#benchmark","title":"Benchmark\u00b6","text":"<p>To demonstrate larger systems can be simulated with lightning.gpu with MPI support, and as a multi-node the example above, we first take a sample quantum circuit Jacobian evaluation of a strongly entangling layered (SEL) circuit using adjoint differentiation. The script will run on four-GPU nodes. Each GPU node has 4 NVIDIA A100 40GB Tensor Core GPUs.</p>"},{"location":"pennylane_final/#conclusion","title":"Conclusion\u00b6","text":"<p>With MPI support, <code>lightning.gpu</code> enables large-scale quantum workloads using multiple nodes and GPUs, making previously intractable simulations feasible. Benchmark tests demonstrate that systems with over 30 qubits can be simulated through distributed computing, with performance improving as more GPUs are employed. By integrating full feature parity into its MPI backend, simulations that once ran on a single GPU can now be easily extended to multi-node and multi-GPU setups by adding a few additional arguments when configuring the <code>lightning.gpu</code> device.</p>"},{"location":"pennylane_presentation/","title":"Quantum Computing using PennyLane library","text":"<p>This presentation is designed to introduce quantum computing using PennyLane, a versatile quantum machine learning library, with a focus on GPU capabilities. The presentation is structured using simple language, interactive examples, and hands-on coding in Jupyter Notebook. We will explore how PennyLane can leverage GPUs for quantum computing tasks and provide real-world examples.</p> <p>PennyLane offers impressive versatility through its support for multiple quantum computing backends:</p> <ul> <li><p>Qiskit: IBM's quantum computing framework</p> </li> <li><p>Cirq: Google's quantum computing library</p> </li> <li><p>Amazon Braket: Amazon's quantum computing service</p> </li> <li><p>Microsoft Azure Quantum: Microsoft's cloud quantum computing platform</p> </li> <li><p>Rigetti Forest: Rigetti's quantum programming toolkit</p> </li> <li><p>ProjectQ: ETH Zurich's open-source quantum computing framework</p> </li> </ul> <p>This wide range of supported backends allows users to develop quantum algorithms that can run on various quantum hardware and simulators without changing their core code.</p> <p>PennyLane places a strong emphasis on GPU compatibility to accelerate quantum simulations and hybrid quantum-classical computations. It leverages GPU acceleration through:</p> <ul> <li>Integration with JAX, a high-performance numerical computing library</li> <li>Support for NVIDIA cuQuantum SDK for GPU-accelerated quantum circuit simulations</li> <li>Compatibility with PyTorch and TensorFlow's GPU operations for classical processing</li> </ul> <p>This GPU focus enables researchers and developers to run large-scale quantum simulations and optimize complex quantum-classical models more efficiently, significantly reducing computation time for quantum machine learning tasks.</p> In\u00a0[69]: Copied! <pre>%%bash\nKERNEL=\"$HOME/.local/share/jupyter/kernels/pennylane\"\nmkdir -p $KERNEL\nPRELOAD=\"$KERNEL/start.sh\"\nJSON=\"$KERNEL/kernel.json\"\ncat &lt;&lt; 'EOF' &gt; $JSON\n{\n \"argv\": [\n  \"{resource_dir}/start.sh\",\n  \"python\",\n  \"-m\",\n  \"ipykernel_launcher\",\n  \"-f\",\n  \"{connection_file}\"\n ],\n \"display_name\": \"PennyLane2\",\n \"language\": \"python\",\n \"metadata\": {\n  \"debugger\": true\n }\n}\nEOF\n\ncat &lt;&lt; 'EOF' &gt; $PRELOAD\n#!/bin/bash\nmodule load matplotlib/3.7.2-gfbf-2023a\nmodule load PennyLane-bundle/0.37.0-foss-2023a-CUDA-12.2.0\nmodule load jaxopt/0.8.3-gfbf-2023a-CUDA-12.1.1\nexec \"$@\"\nEOF\n\nchmod u+x $PRELOAD\n</pre> %%bash KERNEL=\"$HOME/.local/share/jupyter/kernels/pennylane\" mkdir -p $KERNEL PRELOAD=\"$KERNEL/start.sh\" JSON=\"$KERNEL/kernel.json\" cat &lt;&lt; 'EOF' &gt; $JSON {  \"argv\": [   \"{resource_dir}/start.sh\",   \"python\",   \"-m\",   \"ipykernel_launcher\",   \"-f\",   \"{connection_file}\"  ],  \"display_name\": \"PennyLane2\",  \"language\": \"python\",  \"metadata\": {   \"debugger\": true  } } EOF  cat &lt;&lt; 'EOF' &gt; $PRELOAD #!/bin/bash module load matplotlib/3.7.2-gfbf-2023a module load PennyLane-bundle/0.37.0-foss-2023a-CUDA-12.2.0 module load jaxopt/0.8.3-gfbf-2023a-CUDA-12.1.1 exec \"$@\" EOF  chmod u+x $PRELOAD In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[19]: Copied! <pre># This cell is added by sphinx-gallery\n# It can be customized to whatever you like\n%matplotlib inline\n</pre> # This cell is added by sphinx-gallery # It can be customized to whatever you like %matplotlib inline In\u00a0[3]: Copied! <pre>import pennylane as qml\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n</pre> import pennylane as qml import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D In\u00a0[\u00a0]: Copied! <pre># Create a default qubit simulator with 2 qubits\ndev = qml.device('default.qubit', wires=2)\n</pre> # Create a default qubit simulator with 2 qubits dev = qml.device('default.qubit', wires=2) <p>For all devices, <code>device</code> accepts the following arguments:</p> <ul> <li><code>name</code>: the name of the device to be loaded</li> <li><code>wires</code>: the number of subsystems (qubits in qubit model) to initialize the device with. It is also possible to label the wires, for example <code>wires=['q1', 'q2']</code></li> </ul> <p>Some devices also accepts <code>shots</code> option for setting the number of circuit evaluations/random samples used to estimate expectation values of observables.</p> In\u00a0[\u00a0]: Copied! <pre># shots and qubits labels example\ndev_unique_wires = qml.device('default.qubit', wires=['q1', 'q2'], shots = [10, 1000])\n</pre> # shots and qubits labels example dev_unique_wires = qml.device('default.qubit', wires=['q1', 'q2'], shots = [10, 1000]) In\u00a0[\u00a0]: Copied! <pre>def quantum_circuit(params):\n    qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.\n    return qml.state()          # Return the final quantum state\n</pre> def quantum_circuit(params):     qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.     return qml.state()          # Return the final quantum state <p>This is a simple circuit, applying a PauliX gate to the first Qubit, it flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa. Notice that the function <code>quantum_circuit()</code> is constructed as if it were any other Python function; it accepts a positional argument <code>params</code>, which may be a list, tuple, or array, and uses the individual elements for gate parameters.</p> <p>However, quantum functions are a restricted subset of Python functions. For a Python function to also be a valid quantum function, there are some important restrictions:</p> <ul> <li><p>Quantum functions must contain quantum operations, one operation per line, in the order in which they are to be applied.</p> <p>In addition, we must always specify the subsystem the operation applies to, by passing the <code>wires</code> argument; this may be a list or an integer, depending on how many wires the operation acts on.</p> </li> <li><p>Quantum functions must return either a single or a tuple of measured observables.</p> <p>As a result, the quantum function always returns a classical quantity, allowing the QNode to interface with other classical functions (and also other QNodes).</p> </li> </ul> <p>NOTE: Certain devices may only support a subset of the available PennyLane operations/observables, or may even provide additional operations/observables. Please consult the documentation for the plugin/device for more details.</p> <p>Once we have written the quantum function, we convert it into a <code>QNode</code> running on device <code>dev</code> by applying the <code>qnode</code> decorator. directly above the function definition:</p> In\u00a0[\u00a0]: Copied! <pre>@qml.qnode(dev)\ndef quantum_circuit(params):\n    qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.\n    return qml.state()          # Return the final quantum statell\n</pre> @qml.qnode(dev) def quantum_circuit(params):     qml.PauliX(wires=0)         # PauliX gate or Quantum NOT gate:  flips the state of a qubit, changing |0\u27e9 to |1\u27e9 and vice versa.     return qml.state()          # Return the final quantum statell <p>Thus, our <code>quantum_circuit()</code> quantum function is now a QNode, which will run on device <code>dev</code> every time it is evaluated.</p> <p>To evaluate, we simply call the function with some appropriate numerical inputs:</p> In\u00a0[63]: Copied! <pre>params = np.array([0, 1])\nresult = quantum_circuit(params)\nresult\n</pre> params = np.array([0, 1]) result = quantum_circuit(params) result Out[63]: <pre>tensor([0.70710678+0.j, 0.        +0.j, 0.        +0.j, 0.70710678+0.j], requires_grad=True)</pre> <p>We can even print the circuit:</p> In\u00a0[64]: Copied! <pre>print(qml.draw(quantum_circuit)(params))\n</pre> print(qml.draw(quantum_circuit)(params)) <pre>0: \u2500\u2500H\u2500\u256d\u25cf\u2500\u2524  State\n1: \u2500\u2500\u2500\u2500\u2570X\u2500\u2524  State\n</pre> <p>A nicer circuit draw with matplotlib</p> In\u00a0[65]: Copied! <pre>qml.drawer.use_style(\"black_white\")\nfig, ax = qml.draw_mpl(quantum_circuit)(params)\nplt.show()\n</pre> qml.drawer.use_style(\"black_white\") fig, ax = qml.draw_mpl(quantum_circuit)(params) plt.show() <p>This quantum circuit diagram shows our two-qubit system. The top qubit (0) undergoes a Hadamard gate (H) followed by a CNOT on the bottom qubit (1). Both qubits are then measured.</p> In\u00a0[66]: Copied! <pre>from pennylane import numpy as np\n\n# Create a device with 2 qubits using the default qubit simulator\ndev = qml.device('default.qubit', wires=2)\n</pre> from pennylane import numpy as np  # Create a device with 2 qubits using the default qubit simulator dev = qml.device('default.qubit', wires=2) In\u00a0[71]: Copied! <pre>#import pennylane as qml\n#from pennylane import numpy as np\n#import matplotlib.pyplot as plt\n#from mpl_toolkits.mplot3d import Axes3D\n\n\n# Create a device with 2 qubits using the default qubit simulator\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef pauli_gates_circuit():\n    # Apply Pauli-X gate to the first qubit\n    qml.PauliX(wires=0)\n    # Apply Pauli-Y gate to the second qubit\n    qml.PauliY(wires=1)\n    # Apply Pauli-Z gate to the first qubit\n    qml.PauliZ(wires=0)\n    # Measure expectation values of Pauli-Z for both qubits\n    #return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n    return qml.state()\n\n# Run the circuit\nresults = pauli_gates_circuit()\nprint(\"Pauli Gates Circuit Output:\", results)\n</pre> #import pennylane as qml #from pennylane import numpy as np #import matplotlib.pyplot as plt #from mpl_toolkits.mplot3d import Axes3D   # Create a device with 2 qubits using the default qubit simulator dev = qml.device('default.qubit', wires=2)  @qml.qnode(dev) def pauli_gates_circuit():     # Apply Pauli-X gate to the first qubit     qml.PauliX(wires=0)     # Apply Pauli-Y gate to the second qubit     qml.PauliY(wires=1)     # Apply Pauli-Z gate to the first qubit     qml.PauliZ(wires=0)     # Measure expectation values of Pauli-Z for both qubits     #return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]     return qml.state()  # Run the circuit results = pauli_gates_circuit() print(\"Pauli Gates Circuit Output:\", results) <pre>Pauli Gates Circuit Output: [0.+0.j 0.+0.j 0.+0.j 0.-1.j]\n</pre> <p>Circuit representation:</p> In\u00a0[69]: Copied! <pre>qml.drawer.use_style(\"black_white\")\nfig, ax = qml.draw_mpl(pauli_gates_circuit)()\nplt.show()\n</pre> qml.drawer.use_style(\"black_white\") fig, ax = qml.draw_mpl(pauli_gates_circuit)() plt.show() <p>We can also show the qubit states of our Pauli gates circuit:</p> In\u00a0[88]: Copied! <pre># Execute the circuit\nstate = pauli_gates_circuit()\n\n# Extract the individual qubit states\nqubit_states = []\nfor i in range(2):\n    qubit_state = np.zeros(2, dtype=complex)\n    for j in range(2):\n        qubit_state[j] = state[i + 2*j]\n    qubit_states.append(qubit_state)\n\n# Extract the Bloch vector coordinates for each qubit\nbloch_vectors = []\nfor qubit_state in qubit_states:\n    theta = 2 * np.arccos(np.real(qubit_state[0]))\n    phi = np.angle(qubit_state[1]) - np.angle(qubit_state[0])\n    x = np.sin(theta) * np.cos(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(theta)\n    bloch_vectors.append((x, y, z))\n\n# Create a 3D plot\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the Bloch sphere\nu = np.linspace(0, 2 * np.pi, 100)\nv = np.linspace(0, np.pi, 100)\nx_sphere = np.outer(np.cos(u), np.sin(v))\ny_sphere = np.outer(np.sin(u), np.sin(v))\nz_sphere = np.outer(np.ones(np.size(u)), np.cos(v))\nax.plot_surface(x_sphere, y_sphere, z_sphere, color='b', alpha=0.2)\n\n# Plot the Bloch vectors for each qubit\ncolors = ['r', 'g']\nfor i, bloch_vector in enumerate(bloch_vectors):\n    x, y, z = bloch_vector\n    ax.quiver(0, 0, 0, x, y, z, color=colors[i], length=1, arrow_length_ratio=0.1)\n    ax.text(x-i/2+0.1, y, z, f'Qubit {i}', color=colors[i])\n\n# Set the axis labels and limits\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\nax.set_xlim(-1, 1)\nax.set_ylim(-1, 1)\nax.set_zlim(-1, 1)\n\nplt.show()\n</pre> # Execute the circuit state = pauli_gates_circuit()  # Extract the individual qubit states qubit_states = [] for i in range(2):     qubit_state = np.zeros(2, dtype=complex)     for j in range(2):         qubit_state[j] = state[i + 2*j]     qubit_states.append(qubit_state)  # Extract the Bloch vector coordinates for each qubit bloch_vectors = [] for qubit_state in qubit_states:     theta = 2 * np.arccos(np.real(qubit_state[0]))     phi = np.angle(qubit_state[1]) - np.angle(qubit_state[0])     x = np.sin(theta) * np.cos(phi)     y = np.sin(theta) * np.sin(phi)     z = np.cos(theta)     bloch_vectors.append((x, y, z))  # Create a 3D plot fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(111, projection='3d')  # Plot the Bloch sphere u = np.linspace(0, 2 * np.pi, 100) v = np.linspace(0, np.pi, 100) x_sphere = np.outer(np.cos(u), np.sin(v)) y_sphere = np.outer(np.sin(u), np.sin(v)) z_sphere = np.outer(np.ones(np.size(u)), np.cos(v)) ax.plot_surface(x_sphere, y_sphere, z_sphere, color='b', alpha=0.2)  # Plot the Bloch vectors for each qubit colors = ['r', 'g'] for i, bloch_vector in enumerate(bloch_vectors):     x, y, z = bloch_vector     ax.quiver(0, 0, 0, x, y, z, color=colors[i], length=1, arrow_length_ratio=0.1)     ax.text(x-i/2+0.1, y, z, f'Qubit {i}', color=colors[i])  # Set the axis labels and limits ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.set_zlim(-1, 1)  plt.show() In\u00a0[89]: Copied! <pre>@qml.qnode(dev)\ndef hadamard_gate_circuit():\n    # Apply Hadamard gate to the first qubit\n    qml.Hadamard(wires=0)\n    # Apply Hadamard gate to the second qubit\n    qml.Hadamard(wires=1)\n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Run the circuit\nprint(\"Hadamard Gate Circuit Output:\", hadamard_gate_circuit())\nfig, ax = qml.draw_mpl(hadamard_gate_circuit)()\nplt.show()\n</pre> @qml.qnode(dev) def hadamard_gate_circuit():     # Apply Hadamard gate to the first qubit     qml.Hadamard(wires=0)     # Apply Hadamard gate to the second qubit     qml.Hadamard(wires=1)     # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Run the circuit print(\"Hadamard Gate Circuit Output:\", hadamard_gate_circuit()) fig, ax = qml.draw_mpl(hadamard_gate_circuit)() plt.show() <pre>Hadamard Gate Circuit Output: [tensor(0., requires_grad=True), tensor(0., requires_grad=True)]\n</pre> In\u00a0[90]: Copied! <pre>@qml.qnode(dev)\ndef cnot_gate_circuit():\n    # Apply CNOT gate with the first qubit as control and the second qubit as target\n    qml.CNOT(wires=[0, 1])\n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Run the circuit\nprint(\"CNOT Gate Circuit Output:\", cnot_gate_circuit())\nfig, ax = qml.draw_mpl(cnot_gate_circuit)()\nplt.show()\n</pre> @qml.qnode(dev) def cnot_gate_circuit():     # Apply CNOT gate with the first qubit as control and the second qubit as target     qml.CNOT(wires=[0, 1])     # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Run the circuit print(\"CNOT Gate Circuit Output:\", cnot_gate_circuit()) fig, ax = qml.draw_mpl(cnot_gate_circuit)() plt.show() <pre>CNOT Gate Circuit Output: [tensor(0., requires_grad=True), tensor(0., requires_grad=True)]\n</pre> In\u00a0[91]: Copied! <pre>#import pennylane as qml\n#from pennylane import numpy as np\n\n# Create a device with 2 qubits using the default qubit simulator\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef rotation_gates_circuit(angle_x, angle_y, angle_z):\n    # Apply RX rotation gate to the first qubit with angle angle_x\n    qml.RX(angle_x, wires=0)\n    \n    # Apply RY rotation gate to the second qubit with angle angle_y\n    qml.RY(angle_y, wires=1)\n    \n    # Apply RZ rotation gate to the first qubit with angle angle_z\n    qml.RZ(angle_z, wires=0)\n    \n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Example: Set rotation angles for each gate\nangle_x = np.pi / 2   # Rotation angle around the X-axis for Qubit 0\nangle_y = np.pi / 4   # Rotation angle around the Y-axis for Qubit 1\nangle_z = np.pi / 8   # Rotation angle around the Z-axis for Qubit 0\n\n# Run the circuit with the specified angles\nresults = rotation_gates_circuit(angle_x, angle_y, angle_z)\nprint(\"Rotation Gates Circuit Output:\", results)\n\nfig, ax = qml.draw_mpl(rotation_gates_circuit)(angle_x, angle_y, angle_z)\nplt.show()\n</pre> #import pennylane as qml #from pennylane import numpy as np  # Create a device with 2 qubits using the default qubit simulator dev = qml.device('default.qubit', wires=2)  @qml.qnode(dev) def rotation_gates_circuit(angle_x, angle_y, angle_z):     # Apply RX rotation gate to the first qubit with angle angle_x     qml.RX(angle_x, wires=0)          # Apply RY rotation gate to the second qubit with angle angle_y     qml.RY(angle_y, wires=1)          # Apply RZ rotation gate to the first qubit with angle angle_z     qml.RZ(angle_z, wires=0)          # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Example: Set rotation angles for each gate angle_x = np.pi / 2   # Rotation angle around the X-axis for Qubit 0 angle_y = np.pi / 4   # Rotation angle around the Y-axis for Qubit 1 angle_z = np.pi / 8   # Rotation angle around the Z-axis for Qubit 0  # Run the circuit with the specified angles results = rotation_gates_circuit(angle_x, angle_y, angle_z) print(\"Rotation Gates Circuit Output:\", results)  fig, ax = qml.draw_mpl(rotation_gates_circuit)(angle_x, angle_y, angle_z) plt.show() <pre>Rotation Gates Circuit Output: [tensor(2.22044605e-16, requires_grad=True), tensor(0.70710678, requires_grad=True)]\n</pre> In\u00a0[92]: Copied! <pre>@qml.qnode(dev)\ndef swap_gate_circuit():\n    # Apply Hadamard gate to the first qubit to create superposition\n    qml.Hadamard(wires=0)\n    \n    # Apply SWAP gate between the first and second qubits\n    qml.SWAP(wires=[0, 1])\n    \n    # Measure expectation values of Pauli-Z for both qubits\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n\n# Run the circuit\nprint(\"SWAP Gate Circuit Output:\", swap_gate_circuit())\nfig, ax = qml.draw_mpl(swap_gate_circuit)()\nplt.show()\n</pre> @qml.qnode(dev) def swap_gate_circuit():     # Apply Hadamard gate to the first qubit to create superposition     qml.Hadamard(wires=0)          # Apply SWAP gate between the first and second qubits     qml.SWAP(wires=[0, 1])          # Measure expectation values of Pauli-Z for both qubits     return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]  # Run the circuit print(\"SWAP Gate Circuit Output:\", swap_gate_circuit()) fig, ax = qml.draw_mpl(swap_gate_circuit)() plt.show() <pre>SWAP Gate Circuit Output: [tensor(1., requires_grad=True), tensor(0., requires_grad=True)]\n</pre> In\u00a0[\u00a0]: Copied! <pre>@qml.qnode(dev)\ndef two_qubit_qft():\n    # TODO: Apply a Hadamard gate to the first qubit\n    # TODO: Apply a controlled-Phase gate (CRZ) between qubits with phase \u03c0/2\n    # TODO: Apply a Hadamard gate to the second qubit\n    # TODO: SWAP the two qubits\n    return qml.state()\n\n# Test your circuit\nprint(\"2-qubit QFT State:\", two_qubit_qft())\n\n# Draw the circuit\n</pre> @qml.qnode(dev) def two_qubit_qft():     # TODO: Apply a Hadamard gate to the first qubit     # TODO: Apply a controlled-Phase gate (CRZ) between qubits with phase \u03c0/2     # TODO: Apply a Hadamard gate to the second qubit     # TODO: SWAP the two qubits     return qml.state()  # Test your circuit print(\"2-qubit QFT State:\", two_qubit_qft())  # Draw the circuit In\u00a0[23]: Copied! <pre># Uncomment to see the answer\n# %load ./2qft.py\n</pre> # Uncomment to see the answer # %load ./2qft.py <p>For more details on PennyLane, see their website.</p> <p>Creating the corresponding QNode</p> <p>For this example, we will use the <code>lightning.qubit</code> device which uses a custom-built C++ backend to perform fast linear algebra calculations for simulating quantum state-vector evolution.</p> In\u00a0[4]: Copied! <pre>#import pennylane as qml\nfrom jax import numpy as np\nimport jax\n\n# Create the device\ndev = qml.device(\"lightning.qubit\", wires=1)\n\n# Create our circuit\n@qml.qnode(dev)\ndef circuit(params):\n    qml.RX(params[0], wires=0)\n    qml.RY(params[1], wires=0)\n    return qml.expval(qml.PauliZ(0))\n</pre> #import pennylane as qml from jax import numpy as np import jax  # Create the device dev = qml.device(\"lightning.qubit\", wires=1)  # Create our circuit @qml.qnode(dev) def circuit(params):     qml.RX(params[0], wires=0)     qml.RY(params[1], wires=0)     return qml.expval(qml.PauliZ(0)) <p>We can evaluate our <code>circuit</code>:</p> In\u00a0[5]: Copied! <pre>params = np.array([0.54, 0.12])\nprint(circuit(params))\n</pre> params = np.array([0.54, 0.12]) print(circuit(params)) <pre>0.85154057\n</pre> In\u00a0[6]: Copied! <pre>dcircuit = jax.grad(circuit, argnums=0)\n</pre> dcircuit = jax.grad(circuit, argnums=0) <p>The function <code>jax</code> itself returns a function, representing the derivative of the QNode with respect to the argument specified in <code>argnums</code>. In this case, the function <code>circuit</code> takes one argument (<code>params</code>), so we specify <code>argnums=0</code>. Because the argument has two elements, the returned gradient is two-dimensional. We can then evaluate this gradient function at any point in the parameter space.</p> In\u00a0[7]: Copied! <pre>print(dcircuit(params))\n</pre> print(dcircuit(params)) <pre>[-0.5104387  -0.10267819]\n</pre> <p>A note on arguments</p> <p>Quantum circuit functions, being a restricted subset of Python functions, can also make use of multiple positional arguments and keyword arguments. For example, we could have defined the above quantum circuit function using two positional arguments, instead of one array argument:</p> In\u00a0[8]: Copied! <pre>@qml.qnode(dev)\ndef circuit2(phi1, phi2):\n    qml.RX(phi1, wires=0)\n    qml.RY(phi2, wires=0)\n    return qml.expval(qml.PauliZ(0))\n</pre> @qml.qnode(dev) def circuit2(phi1, phi2):     qml.RX(phi1, wires=0)     qml.RY(phi2, wires=0)     return qml.expval(qml.PauliZ(0)) <p>When we calculate the gradient for such a function, the usage of <code>argnums</code> will be slightly different. In this case, <code>argnums=0</code> will return the gradient with respect to only the first parameter (<code>phi1</code>), and <code>argnums=1</code> will give the gradient for <code>phi2</code>. To get the gradient with respect to both parameters, we can use <code>argnums=[0,1]</code>:</p> In\u00a0[9]: Copied! <pre>phi1 = np.array([0.54])\nphi2 = np.array([0.12])\n\ndcircuit = jax.grad(circuit2, argnums=[0, 1])\nprint(dcircuit(phi1, phi2))\n</pre> phi1 = np.array([0.54]) phi2 = np.array([0.12])  dcircuit = jax.grad(circuit2, argnums=[0, 1]) print(dcircuit(phi1, phi2)) <pre>(Array([-0.5104387], dtype=float32), Array([-0.10267819], dtype=float32))\n</pre> <p>Keyword arguments may also be used in your custom quantum function. PennyLane does not differentiate QNodes with respect to keyword arguments, so they are useful for passing external data to your QNode.</p> In\u00a0[10]: Copied! <pre>def cost(x):\n    return circuit(x)\n</pre> def cost(x):     return circuit(x) <p>To begin our optimization, let's choose small initial values of $\\phi_1$ and $\\phi_2$:</p> In\u00a0[11]: Copied! <pre>init_params = np.array([0.011, 0.012])\nprint(cost(init_params))\n</pre> init_params = np.array([0.011, 0.012]) print(cost(init_params)) <pre>0.9998675\n</pre> <p>We can see that, for these initial parameter values, the cost function is close to $1$.</p> <p>Finally, we use an optimizer to update the circuit parameters for 100 steps. We can use the gradient descent optimizer:</p> In\u00a0[12]: Copied! <pre>import jaxopt\n\n# initialise the optimizer\nopt = jaxopt.GradientDescent(cost, stepsize=0.4, acceleration = False)\n\n# set the number of steps\nsteps = 100\n# set the initial parameter values\nparams = init_params\nopt_state = opt.init_state(params)\n\nfor i in range(steps):\n    # update the circuit parameters\n    params, opt_state = opt.update(params, opt_state)\n\n    if (i + 1) % 5 == 0:\n        print(\"Cost after step {:5d}: {: .7f}\".format(i + 1, cost(params)))\n\nprint(\"Optimized rotation angles: {}\".format(params))\n</pre> import jaxopt  # initialise the optimizer opt = jaxopt.GradientDescent(cost, stepsize=0.4, acceleration = False)  # set the number of steps steps = 100 # set the initial parameter values params = init_params opt_state = opt.init_state(params)  for i in range(steps):     # update the circuit parameters     params, opt_state = opt.update(params, opt_state)      if (i + 1) % 5 == 0:         print(\"Cost after step {:5d}: {: .7f}\".format(i + 1, cost(params)))  print(\"Optimized rotation angles: {}\".format(params)) <pre>Cost after step     5:  0.9961779\nCost after step    10:  0.8974943\nCost after step    15:  0.1440490\nCost after step    20: -0.1536721\nCost after step    25: -0.9152497\nCost after step    30: -0.9994046\nCost after step    35: -0.9999964\nCost after step    40: -1.0000000\nCost after step    45: -1.0000000\nCost after step    50: -1.0000000\nCost after step    55: -1.0000000\nCost after step    60: -1.0000000\nCost after step    65: -1.0000000\nCost after step    70: -1.0000000\nCost after step    75: -1.0000000\nCost after step    80: -1.0000000\nCost after step    85: -1.0000000\nCost after step    90: -1.0000000\nCost after step    95: -1.0000000\nCost after step   100: -1.0000000\nOptimized rotation angles: [7.1526473e-18 3.1415925e+00]\n</pre> <p>We can see that the optimization converges after approximately 40 steps.</p> <p>Substituting this into the theoretical result $\\langle \\psi \\mid \\sigma_z \\mid \\psi \\rangle = \\cos\\phi_1\\cos\\phi_2$, we can verify that this is indeed one possible value of the circuit parameters that produces $\\langle \\psi \\mid \\sigma_z \\mid \\psi \\rangle=-1$, resulting in the qubit being rotated to the state $\\left|1\\right\\rangle$.</p> <p>Note: Some optimizers, such as <code>AdagradOptimizer</code>, have internal hyperparameters that are stored in the optimizer instance. These can be reset using the <code>reset</code> method.</p> In\u00a0[\u00a0]: Copied! <pre># This cell is added by sphinx-gallery\n# It can be customized to whatever you like\n%matplotlib inline\n</pre> # This cell is added by sphinx-gallery # It can be customized to whatever you like %matplotlib inline In\u00a0[24]: Copied! <pre>#import pennylane as qml\nimport numpy as np\n\ndef state_preparation(state):\n    qml.StatePrep(state, wires=[\"S\"])\n</pre> #import pennylane as qml import numpy as np  def state_preparation(state):     qml.StatePrep(state, wires=[\"S\"]) In\u00a0[25]: Copied! <pre>def entangle_qubits():\n    qml.Hadamard(wires=\"A\")\n    qml.CNOT(wires=[\"A\", \"B\"])\n</pre> def entangle_qubits():     qml.Hadamard(wires=\"A\")     qml.CNOT(wires=[\"A\", \"B\"]) <p>From now on, the qubit subscripts will be removed from states for brevity.</p> In\u00a0[26]: Copied! <pre>def basis_rotation():\n    qml.CNOT(wires=[\"S\", \"A\"])\n    qml.Hadamard(wires=\"S\")\n</pre> def basis_rotation():     qml.CNOT(wires=[\"S\", \"A\"])     qml.Hadamard(wires=\"S\") In\u00a0[27]: Copied! <pre>def measure_and_update():\n    m0 = qml.measure(\"S\")\n    m1 = qml.measure(\"A\")\n    qml.cond(m1, qml.PauliX)(\"B\")\n    qml.cond(m0, qml.PauliZ)(\"B\")\n</pre> def measure_and_update():     m0 = qml.measure(\"S\")     m1 = qml.measure(\"A\")     qml.cond(m1, qml.PauliX)(\"B\")     qml.cond(m0, qml.PauliZ)(\"B\") <p>We've now defined all the building blocks for the quantum teleportation protocol. Let's put it all together!</p> In\u00a0[28]: Copied! <pre>def teleport(state):\n    state_preparation(state)\n    entangle_qubits()\n    basis_rotation()\n    measure_and_update()\n\n\nstate = np.array([1 / np.sqrt(2) + 0.3j, 0.4 - 0.5j])\n_ = qml.draw_mpl(teleport, style=\"pennylane\")(state)\n</pre> def teleport(state):     state_preparation(state)     entangle_qubits()     basis_rotation()     measure_and_update()   state = np.array([1 / np.sqrt(2) + 0.3j, 0.4 - 0.5j]) _ = qml.draw_mpl(teleport, style=\"pennylane\")(state) <p>There is a neat concept known as the principle of deferred measurement, and it basically states that we can push all our measurements to the end of our circuit. This can be useful for a variety of reasons, such as when working in a system that does not support mid-circuit measurements. In PennyLane, when you bind a circuit to a device that does not support them, it will automatically apply the principle of deferred measurement and update your circuit to use controlled operations instead. Note that you need to specify <code>expansion_strategy=\"device\"</code> when calling <code>draw_mpl</code> so it runs the device pre-processing before drawing the circuit.</p> In\u00a0[29]: Copied! <pre>dev = qml.device(\"default.qubit\", wires=[\"S\", \"A\", \"B\"])\n\n\n@qml.qnode(dev)\ndef teleport(state):\n    state_preparation(state)\n    entangle_qubits()\n    basis_rotation()\n    measure_and_update()\n    return qml.density_matrix(wires=[\"B\"])\n\n\n_ = qml.draw_mpl(teleport, style=\"pennylane\", expansion_strategy=\"device\")(state)\n</pre> dev = qml.device(\"default.qubit\", wires=[\"S\", \"A\", \"B\"])   @qml.qnode(dev) def teleport(state):     state_preparation(state)     entangle_qubits()     basis_rotation()     measure_and_update()     return qml.density_matrix(wires=[\"B\"])   _ = qml.draw_mpl(teleport, style=\"pennylane\", expansion_strategy=\"device\")(state) <p>Poof! Our classical signals have been turned into CNOT and CZ gates. This is exactly what the principle of deferred measurement gives us --- we can apply a CNOT instead of Alice calling Bob and telling him to apply an X gate, and likewise for the CZ gate. This is incredibly useful, as it allows us to perform our correction before any measurements are made. Let's evaluate the action of the CNOT and CZ on Bob's qubit, and ensure that Alice's state has been successfully teleported. Applying the CNOT yields:</p> <p>$$\\frac{1}{2} \\vert 00\\rangle(\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 01\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 10\\rangle (\\alpha\\vert 0\\rangle - \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 11\\rangle (\\alpha\\vert 0\\rangle - \\beta\\vert 1\\rangle)$$</p> <p>Then, applying the CZ yields:</p> <p>$$\\frac{1}{2} \\vert 00\\rangle(\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 01\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 10\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 11\\rangle (\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle)\\tag{3}$$</p> <p>When Alice measures her two qubits at the end, no matter which outcome she gets, Bob's qubit will be in the state $\\alpha\\vert 0\\rangle + \\beta \\vert 1\\rangle$. This means that our protocol has changed the state of Bob's qubit into the one Alice wished to send him, which is truly incredible!</p> <p>We can use <code>qml.density_matrix</code> to trace out and return Bob's subsystem as a density matrix, which is a more general description of the state of his qubit. We will use this to verify that Alice's state was successfully teleported to Bob's qubit. Re-arranging equation (3), we can see that the final state of the system is:</p> <p>$$\\frac{1}{2} (\\vert 00\\rangle + \\vert 01\\rangle + \\vert 10\\rangle + \\vert 11\\rangle) \\vert \\psi\\rangle\\tag{4}$$</p> <p>Now, we can confirm that our implementation of the quantum teleportation protocol is working as expected by comparing Bob's final density matrix to Alice's original density matrix:</p> In\u00a0[30]: Copied! <pre>def teleport_state(state):\n    teleported_density_matrix = teleport(state)\n    original_density_matrix = qml.math.dm_from_state_vector(state)\n\n    if not np.allclose(teleported_density_matrix, original_density_matrix):\n        raise ValueError(\n            f\"Alice's state ({state}) not teleported properly. \"\n            f\"Final density matrix of Bob's subsystem: {teleported_density_matrix}\"\n        )\n    print(\"State successfully teleported!\")\n\n\nteleport_state(state)\n</pre> def teleport_state(state):     teleported_density_matrix = teleport(state)     original_density_matrix = qml.math.dm_from_state_vector(state)      if not np.allclose(teleported_density_matrix, original_density_matrix):         raise ValueError(             f\"Alice's state ({state}) not teleported properly. \"             f\"Final density matrix of Bob's subsystem: {teleported_density_matrix}\"         )     print(\"State successfully teleported!\")   teleport_state(state) <pre>State successfully teleported!\n</pre> <p>Reload modules</p> In\u00a0[1]: Copied! <pre>import pennylane as qml\nimport matplotlib.pyplot as plt\n</pre> import pennylane as qml import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>#import pennylane as qml\nfrom timeit import default_timer as timer\nimport os\n\n# To set the number of threads used when executing this script,\nos.environ['OMP_NUM_THREADS'] = '128'\n\n# Choose number of qubits (wires) and circuit layers\nwires = 20\nlayers = 3\n\n# Set number of runs for timing averaging\nnum_runs = 5\n\n# Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device\ndev_gpu = qml.device('lightning.gpu', wires=wires)\ndev_cpu = qml.device('lightning.qubit', wires=wires)\n\n# Create QNode of device and circuit\n@qml.qnode(dev_cpu, diff_method=\"adjoint\")\ndef circuit_cpu(parameters):\n    qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))\n    return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])    \n\n@qml.qnode(dev_gpu, diff_method=\"adjoint\")\ndef circuit_gpu(parameters):\n    qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))\n    return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])\n\n\n# Set trainable parameters for calculating circuit Jacobian\nshape = qml.StronglyEntanglingLayers.shape(n_layers=layers, n_wires=wires)\nweights = qml.numpy.random.random(size=shape)\n\n# Run, calculate the quantum circuit Jacobian and average the timing results\ntiming_cpu = []\ntiming_gpu = []\n\nfor t in range(num_runs):\n    start = timer()\n    jac = qml.jacobian(circuit_cpu)(weights)\n    end = timer()\n    timing_cpu.append(end - start)\n\nfor t in range(num_runs):\n    start = timer()\n    jac = qml.jacobian(circuit_gpu)(weights)\n    end = timer()\n    timing_gpu.append(end - start)\n\n#print(qml.numpy.mean(timing))\n\nprint(timing_cpu)\nprint(timing_gpu)\n</pre> #import pennylane as qml from timeit import default_timer as timer import os  # To set the number of threads used when executing this script, os.environ['OMP_NUM_THREADS'] = '128'  # Choose number of qubits (wires) and circuit layers wires = 20 layers = 3  # Set number of runs for timing averaging num_runs = 5  # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device dev_gpu = qml.device('lightning.gpu', wires=wires) dev_cpu = qml.device('lightning.qubit', wires=wires)  # Create QNode of device and circuit @qml.qnode(dev_cpu, diff_method=\"adjoint\") def circuit_cpu(parameters):     qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))     return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])      @qml.qnode(dev_gpu, diff_method=\"adjoint\") def circuit_gpu(parameters):     qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))     return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])   # Set trainable parameters for calculating circuit Jacobian shape = qml.StronglyEntanglingLayers.shape(n_layers=layers, n_wires=wires) weights = qml.numpy.random.random(size=shape)  # Run, calculate the quantum circuit Jacobian and average the timing results timing_cpu = [] timing_gpu = []  for t in range(num_runs):     start = timer()     jac = qml.jacobian(circuit_cpu)(weights)     end = timer()     timing_cpu.append(end - start)  for t in range(num_runs):     start = timer()     jac = qml.jacobian(circuit_gpu)(weights)     end = timer()     timing_gpu.append(end - start)  #print(qml.numpy.mean(timing))  print(timing_cpu) print(timing_gpu) <pre>[8.834768506931141, 9.151098940055817, 9.2119702140335, 9.15863941598218, 9.171202237950638]\n[1.6982544480124488, 0.3714287990005687, 0.3715393899474293, 0.37124369002413005, 0.3702543319668621]\n</pre> In\u00a0[3]: Copied! <pre>#import pennylane as qml\nfrom timeit import default_timer as timer\nimport os\nimport numpy as np\n#import matplotlib.pyplot as plt\n\n# Parameters to test\n#wires_range = range(10, 33)  # Wires from 10 to 32\nwires_range = [10, 15, 20]  # Wires from 10 to 32\nlayers_range = range(1, 4)   # Layers from 1 to 3\nomp_threads_list = [128]  # OMP_NUM_THREADS values\n\n# Number of runs for timing averaging\nnum_runs = 2\n\n# Dictionary to store timing results\ntiming_results = {\n    'cpu': np.zeros((len(wires_range), len(layers_range), len(omp_threads_list))),\n    'gpu': np.zeros((len(wires_range), len(layers_range), len(omp_threads_list)))\n}\n\n# Run simulations for each combination of parameters\nfor i, wires in enumerate(wires_range):\n    for j, layers in enumerate(layers_range):\n        for k, omp_threads in enumerate(omp_threads_list):\n            # Set the number of threads\n            os.environ['OMP_NUM_THREADS'] = str(omp_threads)\n            \n            # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device\n            dev_gpu = qml.device('lightning.gpu', wires=wires)\n            dev_cpu = qml.device('lightning.qubit', wires=wires)\n\n            # Define QNodes\n            @qml.qnode(dev_cpu, diff_method=\"adjoint\")\n            def circuit_cpu(parameters):\n                qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))\n                return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])\n\n            @qml.qnode(dev_gpu, diff_method=\"adjoint\")\n            def circuit_gpu(parameters):\n                qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))\n                return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])\n            \n            # Set trainable parameters\n            shape = qml.StronglyEntanglingLayers.shape(n_layers=layers, n_wires=wires)\n            weights = qml.numpy.random.random(size=shape)\n\n            # Measure CPU timing\n            cpu_timings = []\n            for _ in range(num_runs):\n                start = timer()\n                jac = qml.jacobian(circuit_cpu)(weights)\n                end = timer()\n                cpu_timings.append(end - start)\n            avg_cpu_time = np.mean(cpu_timings)\n            timing_results['cpu'][i, j, k] = avg_cpu_time\n\n            # Measure GPU timing\n            gpu_timings = []\n            for _ in range(num_runs):\n                start = timer()\n                jac = qml.jacobian(circuit_gpu)(weights)\n                end = timer()\n                gpu_timings.append(end - start)\n            avg_gpu_time = np.mean(gpu_timings)\n            timing_results['gpu'][i, j, k] = avg_gpu_time\n\n            print(f\"Completed: Wires={wires}, Layers={layers}, OMP_NUM_THREADS={omp_threads}, CPU time={avg_cpu_time:.4f}s, GPU time={avg_gpu_time:.4f}s\")\n</pre> #import pennylane as qml from timeit import default_timer as timer import os import numpy as np #import matplotlib.pyplot as plt  # Parameters to test #wires_range = range(10, 33)  # Wires from 10 to 32 wires_range = [10, 15, 20]  # Wires from 10 to 32 layers_range = range(1, 4)   # Layers from 1 to 3 omp_threads_list = [128]  # OMP_NUM_THREADS values  # Number of runs for timing averaging num_runs = 2  # Dictionary to store timing results timing_results = {     'cpu': np.zeros((len(wires_range), len(layers_range), len(omp_threads_list))),     'gpu': np.zeros((len(wires_range), len(layers_range), len(omp_threads_list))) }  # Run simulations for each combination of parameters for i, wires in enumerate(wires_range):     for j, layers in enumerate(layers_range):         for k, omp_threads in enumerate(omp_threads_list):             # Set the number of threads             os.environ['OMP_NUM_THREADS'] = str(omp_threads)                          # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device             dev_gpu = qml.device('lightning.gpu', wires=wires)             dev_cpu = qml.device('lightning.qubit', wires=wires)              # Define QNodes             @qml.qnode(dev_cpu, diff_method=\"adjoint\")             def circuit_cpu(parameters):                 qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))                 return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])              @qml.qnode(dev_gpu, diff_method=\"adjoint\")             def circuit_gpu(parameters):                 qml.StronglyEntanglingLayers(weights=parameters, wires=range(wires))                 return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(wires)])                          # Set trainable parameters             shape = qml.StronglyEntanglingLayers.shape(n_layers=layers, n_wires=wires)             weights = qml.numpy.random.random(size=shape)              # Measure CPU timing             cpu_timings = []             for _ in range(num_runs):                 start = timer()                 jac = qml.jacobian(circuit_cpu)(weights)                 end = timer()                 cpu_timings.append(end - start)             avg_cpu_time = np.mean(cpu_timings)             timing_results['cpu'][i, j, k] = avg_cpu_time              # Measure GPU timing             gpu_timings = []             for _ in range(num_runs):                 start = timer()                 jac = qml.jacobian(circuit_gpu)(weights)                 end = timer()                 gpu_timings.append(end - start)             avg_gpu_time = np.mean(gpu_timings)             timing_results['gpu'][i, j, k] = avg_gpu_time              print(f\"Completed: Wires={wires}, Layers={layers}, OMP_NUM_THREADS={omp_threads}, CPU time={avg_cpu_time:.4f}s, GPU time={avg_gpu_time:.4f}s\")  <pre>Completed: Wires=10, Layers=1, OMP_NUM_THREADS=128, CPU time=0.0200s, GPU time=0.2230s\nCompleted: Wires=10, Layers=2, OMP_NUM_THREADS=128, CPU time=0.0174s, GPU time=0.0413s\nCompleted: Wires=10, Layers=3, OMP_NUM_THREADS=128, CPU time=0.0245s, GPU time=0.0537s\nCompleted: Wires=15, Layers=1, OMP_NUM_THREADS=128, CPU time=0.0388s, GPU time=0.0482s\nCompleted: Wires=15, Layers=2, OMP_NUM_THREADS=128, CPU time=0.0700s, GPU time=0.0769s\nCompleted: Wires=15, Layers=3, OMP_NUM_THREADS=128, CPU time=0.0996s, GPU time=0.1076s\nCompleted: Wires=20, Layers=1, OMP_NUM_THREADS=128, CPU time=3.4070s, GPU time=0.1590s\nCompleted: Wires=20, Layers=2, OMP_NUM_THREADS=128, CPU time=6.7325s, GPU time=0.4557s\nCompleted: Wires=20, Layers=3, OMP_NUM_THREADS=128, CPU time=9.7900s, GPU time=0.4945s\n</pre> In\u00a0[4]: Copied! <pre># Enable inline plotting\n%matplotlib inline\n# Plotting the results for each layer separately\nfor j, layers in enumerate(layers_range):\n    fig, ax = plt.subplots(figsize=(12, 8))\n    \n    width = 0.15  # Width of the bars\n    x = np.arange(len(wires_range))  # X-axis positions\n\n    # Create bar plots for each OMP_NUM_THREADS configuration\n    for k, omp_threads in enumerate(omp_threads_list):\n        offset = (k - len(omp_threads_list) / 2) * width\n        ax.bar(x + offset, timing_results['cpu'][:, j, k], width, label=f'CPU, OMP={omp_threads}')\n        ax.bar(x + offset, timing_results['gpu'][:, j, k], width, label=f'GPU, OMP={omp_threads}', hatch='//')\n\n    # Formatting the plot\n    ax.set_xlabel('Number of Wires (Qubits)')\n    ax.set_ylabel('Average Time (seconds, log scale)')\n    ax.set_title(f'Timing Results for Different Wires (Layers={layers})')\n    ax.set_xticks(x)\n    ax.set_xticklabels(wires_range)\n    #ax.set_yscale('log')  # Set y-axis to logarithmic scale\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1))\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.show()\n</pre> # Enable inline plotting %matplotlib inline # Plotting the results for each layer separately for j, layers in enumerate(layers_range):     fig, ax = plt.subplots(figsize=(12, 8))          width = 0.15  # Width of the bars     x = np.arange(len(wires_range))  # X-axis positions      # Create bar plots for each OMP_NUM_THREADS configuration     for k, omp_threads in enumerate(omp_threads_list):         offset = (k - len(omp_threads_list) / 2) * width         ax.bar(x + offset, timing_results['cpu'][:, j, k], width, label=f'CPU, OMP={omp_threads}')         ax.bar(x + offset, timing_results['gpu'][:, j, k], width, label=f'GPU, OMP={omp_threads}', hatch='//')      # Formatting the plot     ax.set_xlabel('Number of Wires (Qubits)')     ax.set_ylabel('Average Time (seconds, log scale)')     ax.set_title(f'Timing Results for Different Wires (Layers={layers})')     ax.set_xticks(x)     ax.set_xticklabels(wires_range)     #ax.set_yscale('log')  # Set y-axis to logarithmic scale     ax.legend(loc='upper left', bbox_to_anchor=(1, 1))     plt.xticks(rotation=45)     plt.tight_layout()     plt.show() <p>For short circuits with few numbers of qubits, the overheads of running the GPU device (initialization, memory allocations, initial copies) can tend to dominate, but for simulations in the 20 qubits and above region the GPU device shines! The above figure shows that we see an ever-widening gap for Jacobian evaluations with over an order-of-magnitude timing reduction for large simulations relative to both single and multi-threaded CPU-based simulation. We also expect to see the same behavior for deep quantum circuits, where the initial setup overhead is minimal compared to the gates count required for the simulation.</p> In\u00a0[5]: Copied! <pre>dev = qml.device(\"lightning.gpu\", wires = wires, mpi = True, mpi_buf_size=1024)\n</pre> dev = qml.device(\"lightning.gpu\", wires = wires, mpi = True, mpi_buf_size=1024) <pre>mel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_1: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_0: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_1: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_1: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_0: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_1: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_1: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_0: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_1: Operation not permitted\nmel2183:rank0.python: Failed to modify UD QP to INIT on mlx5_1: Operation not permitted\n</pre> <pre>/apps/USE/easybuild/release/2023.1/software/PennyLane-Lightning-GPU/0.37.0-foss-2023a-CUDA-12.2.0/lib/python3.11/site-packages/pennylane_lightning/lightning_gpu/lightning_gpu.py:278: RuntimeWarning: The MPI buffer size is larger than the local state vector size.\n  warn(\n</pre> <p>With this, <code>lightning.gpu</code> will automatically distribute and initialize a complete state vector across multiple GPUs. Each GPU is assigned a subsystem and <code>mpi_buf_size (MiB)</code> of device memory shared as a data buffer to assist with the MPI communications for quantum gate calls.</p> In\u00a0[6]: Copied! <pre>from mpi4py import MPI\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom timeit import default_timer as timer\n\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n\n# Set number of runs for timing averaging\nnum_runs = 3\n\nprint(size)\n\n# Choose number of qubits (wires) and circuit layers\nn_wires = 32\nn_layers = 2\n\n# Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device\n# mpi=True to switch on distributed simulation\n# batch_obs=True to reduce the device memory demand for adjoint backpropagation\ndev = qml.device('lightning.gpu', wires=n_wires, mpi=True, batch_obs=True)\n\n# Create QNode of device and circuit\n@qml.qnode(dev, diff_method=\"adjoint\")\ndef circuit_adj(weights):\n    qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))\n    return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(n_wires)])\n\n# Set trainable parameters for calculating circuit Jacobian at the rank=0 process\nif rank == 0:\n    params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires))\nelse:\n    params = None\n\n# Broadcast the trainable parameters across MPI processes from rank=0 process\nparams = comm.bcast(params, root=0)\n\n# Run, calculate the quantum circuit Jacobian and average the timing results\ntiming = []\nfor t in range(num_runs):\n    start = timer()\n    jac = qml.jacobian(circuit_adj)(params)\n    end = timer()\n    timing.append(end - start)\n\n# MPI barrier to ensure all calculations are done\ncomm.Barrier()\n\nif rank == 0:\n    print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))\n</pre> from mpi4py import MPI import pennylane as qml from pennylane import numpy as np from timeit import default_timer as timer  comm = MPI.COMM_WORLD rank = comm.Get_rank() size = comm.Get_size()  # Set number of runs for timing averaging num_runs = 3  print(size)  # Choose number of qubits (wires) and circuit layers n_wires = 32 n_layers = 2  # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device # mpi=True to switch on distributed simulation # batch_obs=True to reduce the device memory demand for adjoint backpropagation dev = qml.device('lightning.gpu', wires=n_wires, mpi=True, batch_obs=True)  # Create QNode of device and circuit @qml.qnode(dev, diff_method=\"adjoint\") def circuit_adj(weights):     qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))     return qml.math.hstack([qml.expval(qml.PauliZ(i)) for i in range(n_wires)])  # Set trainable parameters for calculating circuit Jacobian at the rank=0 process if rank == 0:     params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires)) else:     params = None  # Broadcast the trainable parameters across MPI processes from rank=0 process params = comm.bcast(params, root=0)  # Run, calculate the quantum circuit Jacobian and average the timing results timing = [] for t in range(num_runs):     start = timer()     jac = qml.jacobian(circuit_adj)(params)     end = timer()     timing.append(end - start)  # MPI barrier to ensure all calculations are done comm.Barrier()  if rank == 0:     print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))   <pre>1\n</pre> <pre>\n---------------------------------------------------------------------------\nLightningException                        Traceback (most recent call last)\nCell In[6], line 22\n     17 n_layers = 2\n     19 # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device\n     20 # mpi=True to switch on distributed simulation\n     21 # batch_obs=True to reduce the device memory demand for adjoint backpropagation\n---&gt; 22 dev = qml.device('lightning.gpu', wires=n_wires, mpi=True, batch_obs=True)\n     24 # Create QNode of device and circuit\n     25 @qml.qnode(dev, diff_method=\"adjoint\")\n     26 def circuit_adj(weights):\n\nFile /apps/USE/easybuild/release/2023.1/software/PennyLane/0.37.0-foss-2023a/lib/python3.11/site-packages/pennylane/__init__.py:413, in device(name, *args, **kwargs)\n    407     raise DeviceError(\n    408         f\"The {name} plugin requires PennyLane versions {plugin_device_class.pennylane_requires}, \"\n    409         f\"however PennyLane version {__version__} is installed.\"\n    410     )\n    412 # Construct the device\n--&gt; 413 dev = plugin_device_class(*args, **options)\n    415 # Once the device is constructed, we set its custom expansion function if\n    416 # any custom decompositions were specified.\n    417 if custom_decomps is not None:\n\nFile /apps/USE/easybuild/release/2023.1/software/PennyLane-Lightning-GPU/0.37.0-foss-2023a-CUDA-12.2.0/lib/python3.11/site-packages/pennylane_lightning/lightning_gpu/lightning_gpu.py:283, in LightningGPU.__init__(self, wires, mpi, mpi_buf_size, sync, c_dtype, shots, batch_obs)\n    277             w_msg = \"The MPI buffer size is larger than the local state vector size.\"\n    278             warn(\n    279                 w_msg,\n    280                 RuntimeWarning,\n    281             )\n--&gt; 283     self._gpu_state = _gpu_dtype(c_dtype, mpi)(\n    284 self._mpi_manager,\n    285 self._devtag,\n    286 mpi_buf_size,\n    287 self._num_global_wires,\n    288 self._num_local_wires,\n    289 )\n    291 self._sync = sync\n    292 self._batch_obs = batch_obs\n\nLightningException: [/dev/shm/apps/PennyLaneLightningGPU/0.37.0/foss-2023a-CUDA-12.2.0/pennylane_lightning_gpu/pennylane_lightning_gpu-0.37.0/pennylane_lightning/core/src/utils/cuda_utils/DataBuffer.hpp][Line:66][Method:DataBuffer]: Error in PennyLane Lightning: out of memory</pre> <p>Using 4 GPU nodes (16 NVIDIA A100 40GB GPUs), this simulation can easily be scaled to up to 32 qubits. For short circuits with fewer qubits, the overheads of MPI communication across GPUs/nodes may tend to dominate, but for simulations in the region of 28 qubits and above, the computation scales almost linearly!</p> In\u00a0[\u00a0]: Copied! <pre>from mpi4py import MPI\nimport pennylane as qml\nimport numpy as np\nfrom timeit import default_timer as timer\n\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n\n# Set number of runs for timing averaging\nnum_runs = 3\n\n# Choose number of qubits (wires) and circuit layers\nn_wires = 33\nn_layers = 2\n\n# Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device.\n# mpi=True to switch on distributed simulation\ndev = qml.device('lightning.gpu', wires=n_wires, mpi=True)\n\n# Set target wires for probability calculation\nprob_wires = range(n_wires)\n\n# Create QNode of device and circuit\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))\n    return qml.probs(wires=prob_wires)\n\n# Set trainable parameters for calculating circuit Jacobian at the rank=0 process\nif rank == 0:\n    params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires))\nelse:\n    params = None\n\n# Broadcast the trainable parameters across MPI processes from rank=0 process \nparams = comm.bcast(params, root=0)\n\n# Run, calculate the quantum circuit Jacobian and average the timing results\ntiming = []\nfor t in range(num_runs):\n    start = timer()\n    local_probs = circuit(params)\n    end = timer()\n    timing.append(end - start)\n\n# MPI barrier to ensure all calculations are done\ncomm.Barrier()\n\nif rank == 0:\n    print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))\n</pre> from mpi4py import MPI import pennylane as qml import numpy as np from timeit import default_timer as timer  comm = MPI.COMM_WORLD rank = comm.Get_rank() size = comm.Get_size()  # Set number of runs for timing averaging num_runs = 3  # Choose number of qubits (wires) and circuit layers n_wires = 33 n_layers = 2  # Instantiate CPU (lightning.qubit) or GPU (lightning.gpu) device. # mpi=True to switch on distributed simulation dev = qml.device('lightning.gpu', wires=n_wires, mpi=True)  # Set target wires for probability calculation prob_wires = range(n_wires)  # Create QNode of device and circuit @qml.qnode(dev) def circuit(weights):     qml.StronglyEntanglingLayers(weights, wires=list(range(n_wires)))     return qml.probs(wires=prob_wires)  # Set trainable parameters for calculating circuit Jacobian at the rank=0 process if rank == 0:     params = np.random.random(qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires)) else:     params = None  # Broadcast the trainable parameters across MPI processes from rank=0 process  params = comm.bcast(params, root=0)  # Run, calculate the quantum circuit Jacobian and average the timing results timing = [] for t in range(num_runs):     start = timer()     local_probs = circuit(params)     end = timer()     timing.append(end - start)  # MPI barrier to ensure all calculations are done comm.Barrier()  if rank == 0:     print(\"num_gpus: \", size, \" wires: \", n_wires, \" layers \", n_layers, \" time: \", qml.numpy.mean(timing))   <p>Simulations of a 33-qubit system distributed across multiple GPUs demonstrate that computation accelerates with more GPUs, exhibiting near-linear scalability and maintaining parallel efficiency even when utilizing up to 256 GPUs.</p>"},{"location":"pennylane_presentation/#quantum-computing-using-pennylane-library","title":"Quantum Computing using PennyLane library\u00b6","text":""},{"location":"pennylane_presentation/#prerequisites","title":"Prerequisites\u00b6","text":"<ol> <li><p>Basic Python programming skills:</p> <ul> <li>Familiarity with Python syntax</li> <li>Understanding of functions, loops, and conditional statements</li> <li>Experience with common data types (lists, dictionaries, etc.)</li> </ul> </li> <li><p>Basic mathematics:</p> <ul> <li>Comfort with high school level algebra</li> <li>Familiarity with complex numbers (helpful but not required)</li> </ul> </li> </ol> <p>No prior knowledge of quantum computing is required. This tutorial is designed to introduce quantum computing concepts from the ground up using PennyLane.</p>"},{"location":"pennylane_presentation/#table-of-contents","title":"Table of contents\u00b6","text":"<ol> <li><p>Introduction</p> </li> <li><p>PennyLane</p> </li> <li><p>Jupyter Kernel</p> </li> <li><p>Using PennyLane</p> <ol> <li><p>Quantum gates and circuits in PennnyLane</p> </li> <li><p>First example: Qubit rotation and Introduction to Quantum Optmization</p> </li> <li><p>Quantum Teleportation</p> </li> </ol> </li> <li><p>PennyLane GPU device</p> <p>a. Single GPU Quuantum Simulations b. Benchmark CPU vs GPU c. Distributed GPU with MPI</p> </li> <li><p>Conclusion</p> </li> </ol>"},{"location":"pennylane_presentation/#introduction-to-quantum-computing","title":"Introduction to quantum Computing\u00b6","text":""},{"location":"pennylane_presentation/#classical-vs-quantum-computing","title":"Classical vs Quantum Computing\u00b6","text":"<p>Classical computing uses bits (0s and 1s) to process information sequentially. Quantum computing uses qubits, which can exist in multiple states simultaneously, allowing for parallel processing. Think of classical computing as a linear path through a maze, while quantum computing explores all paths at once.</p>"},{"location":"pennylane_presentation/#qubits","title":"Qubits\u00b6","text":"<p>Qubits are the fundamental unit of quantum information. Unlike classical bits, which are either 0 or 1, qubits can be in a combination of both states. Imagine a coin spinning on a table - while it's spinning, it's neither heads nor tails, but a combination of both.</p>"},{"location":"pennylane_presentation/#superposition","title":"Superposition:\u00b6","text":"<p>Superposition is the ability of a qubit to be in multiple states at once. It's like having a box with a ball that can be in every possible position inside the box simultaneously until you open it to look.</p>"},{"location":"pennylane_presentation/#schrodingers-cat-metaphor","title":"Schr\u00f6dinger's Cat Metaphor\u00b6","text":"<p>This famous thought experiment illustrates superposition. Imagine a cat in a box with a device that may or may not have killed it. According to quantum mechanics, until we open the box, the cat is simultaneously alive and dead. This represents how a qubit can be in multiple states until measured.</p>"},{"location":"pennylane_presentation/#entanglement","title":"Entanglement:\u00b6","text":"<p>Entanglement occurs when qubits are connected in such a way that the state of one cannot be described independently of the other. It's like having two magical coins that always land on the same side, even when flipped far apart.</p>"},{"location":"pennylane_presentation/#quantum-gates","title":"Quantum Gates:\u00b6","text":"<p>Quantum gates are operations applied to qubits to manipulate their states. They're similar to logic gates in classical computing, but they can create and manipulate superposition and entanglement. Think of them as special lenses that can change the \"spin\" of our quantum coin in unique ways.</p>"},{"location":"pennylane_presentation/#why-using-quantum-computing","title":"Why using Quantum Computing?\u00b6","text":""},{"location":"pennylane_presentation/#potential-applications-of-quantum-computing","title":"Potential Applications of Quantum Computing\u00b6","text":""},{"location":"pennylane_presentation/#cryptography","title":"Cryptography\u00b6","text":"<p>Quantum computers could break many current encryption methods, but also enable ultra-secure quantum encryption. This could revolutionize data security and privacy.</p>"},{"location":"pennylane_presentation/#optimization","title":"Optimization\u00b6","text":"<p>Solving complex optimization problems in logistics, finance, and engineering. Quantum algorithms could find optimal solutions much faster than classical computers.</p>"},{"location":"pennylane_presentation/#material-science","title":"Material Science\u00b6","text":"<p>Simulating quantum systems to discover new materials with specific properties. This could lead to breakthroughs in battery technology, solar cells, and superconductors.</p>"},{"location":"pennylane_presentation/#drug-discovery","title":"Drug Discovery\u00b6","text":"<p>Modeling molecular interactions to accelerate drug development and potentially find cures for diseases that are currently intractable.</p>"},{"location":"pennylane_presentation/#financial-modeling","title":"Financial Modeling\u00b6","text":"<p>Improving portfolio optimization, risk analysis, and fraud detection in the financial sector.</p>"},{"location":"pennylane_presentation/#climate-modeling","title":"Climate Modeling\u00b6","text":"<p>Enhancing climate change predictions and helping to develop more effective mitigation strategies.</p>"},{"location":"pennylane_presentation/#real-world-examples-companies-exploring-quantum-computing","title":"Real-World Examples: Companies Exploring Quantum Computing\u00b6","text":""},{"location":"pennylane_presentation/#google","title":"Google\u00b6","text":"<ul> <li>Achieved \"quantum supremacy\" in 2019 with their 53-qubit Sycamore processor.</li> <li>Developing error-corrected quantum computers and quantum machine learning algorithms.</li> </ul>"},{"location":"pennylane_presentation/#ibm","title":"IBM\u00b6","text":"<ul> <li>Offers cloud-based quantum computing services through IBM Quantum Experience.</li> <li>Working on building larger quantum processors and developing quantum software tools.</li> </ul>"},{"location":"pennylane_presentation/#microsoft","title":"Microsoft\u00b6","text":"<ul> <li>Developing topological qubits for more stable quantum computations.</li> <li>Created Q#, a programming language for quantum computing.</li> </ul>"},{"location":"pennylane_presentation/#d-wave-systems","title":"D-Wave Systems\u00b6","text":"<ul> <li>Focuses on quantum annealing for optimization problems.</li> <li>Has sold quantum annealing systems to companies and research institutions.</li> </ul>"},{"location":"pennylane_presentation/#rigetti-computing","title":"Rigetti Computing\u00b6","text":"<ul> <li>Building hybrid quantum-classical computing systems.</li> <li>Offers cloud access to their quantum processors.</li> </ul>"},{"location":"pennylane_presentation/#ionq","title":"IonQ\u00b6","text":"<ul> <li>Developing trapped-ion quantum computers.</li> <li>Achieved high-fidelity operations on their quantum processors.</li> </ul> <p>These companies are pushing the boundaries of quantum computing, working to overcome current limitations and bring practical quantum applications to various industries.</p>"},{"location":"pennylane_presentation/#introduction-pennylane","title":"Introduction PennyLane\u00b6","text":""},{"location":"pennylane_presentation/#what-is-pennylane","title":"What is PennyLane?\u00b6","text":"<p>PennyLane is a cross-platform Python library for quantum computing, quantum machine learning, and quantum chemistry.</p> <p>It provides a unified approach to hybrid quantum-classical computation, allowing smooth integration of quantum hardware with classical machine learning libraries like PyTorch and TensorFlow.</p>"},{"location":"pennylane_presentation/#pennylane-vs-other-frameworks","title":"PennyLane vs other Frameworks\u00b6","text":"<p>Let's breakddown the main difference between PennyLane and some other popular frameworks:</p> Framework Focus Key Feature Backend PennyLane Quantum machine learning and variational algorithms Seamless integration with classical ML libraries Multiple (IBM, Google, Amazon) Qiskit (IBM) General-purpose quantum computing Comprehensive toolset for IBM quantum hardware Primarily IBM, can integrate others Cirq (Google) Near-term quantum algorithms and hardware Low-level control over qubit placement and timing Google's hardware, usable with others Q# (Microsoft) High-level quantum programming Domain-specific language for quantum computing Microsoft's simulators and future hardware Amazon Braket Access to multiple quantum hardware providers Unified interface for different quantum processors Multiple (D-Wave, IonQ, Rigetti) Rigetti Forest (pyQuil) Quantum programming for Rigetti hardware Quil assembly language for quantum instructions Rigetti processors and simulators Xanadu Strawberry Fields Continuous-variable quantum computing Photonic quantum computing simulations Xanadu's photonic hardware and simulators D-Wave Ocean Quantum annealing and hybrid solvers Optimization problems and sampling applications D-Wave's quantum annealers QuTiP Dynamics of open quantum systems Comprehensive library for quantum optics Classical simulation of quantum systems ProjectQ High-level quantum programming Compiler framework for quantum circuits Multiple (IBM and classical simulators) TensorFlow Quantum Quantum machine learning research Integration with TensorFlow ecosystem Cirq-based simulators and Google hardware <p>Key Differences</p> <p>Hardware Access: Varies from specialized (D-Wave, Rigetti) to multi-platform (PennyLane, Amazon Braket) Abstraction Level: Ranges from low-level (Cirq) to high-level (Q#) Application Focus: General-purpose (Qiskit) vs. specialized (Strawberry Fields for photonics) Integration: Some focus on classical-quantum integration (PennyLane, TensorFlow Quantum) more than others1. PennyLane</p>"},{"location":"pennylane_presentation/#setting-our-jupyternotebook","title":"Setting our Jupyternotebook\u00b6","text":""},{"location":"pennylane_presentation/#pennylane-kernel","title":"PennyLane kernel\u00b6","text":""},{"location":"pennylane_presentation/#reload-environment","title":"Reload environment\u00b6","text":""},{"location":"pennylane_presentation/#inline-matplotlib-for-plots-in-jupyter","title":"Inline matplotlib for plots in Jupyter\u00b6","text":""},{"location":"pennylane_presentation/#import-packages-to-be-used","title":"Import packages to be used\u00b6","text":""},{"location":"pennylane_presentation/#using-pennylane","title":"Using PennyLane\u00b6","text":""},{"location":"pennylane_presentation/#defining-a-quantum-device-and-circuit","title":"Defining a Quantum Device and Circuit\u00b6","text":""},{"location":"pennylane_presentation/#device","title":"Device\u00b6","text":"<p>The first step in <code>PennyLane</code> is to always initialize a device to run on.</p>"},{"location":"pennylane_presentation/#definition","title":"Definition\u00b6","text":"<p>Any computational object that can apply quantum operations and return a measurement value is called a quantum device.</p> <p>In PennyLane, a device could be a hardware device (real Quantum Computer), or a software simulator (such as our high performance simulator, Qiskit ...).</p> <p>NOTE: Devices are loaded in PennyLane via the function <code>device()</code>.</p> <p>PennyLane supports devices using both the qubit model of quantum computation and devices using the Continuous Variable (CV) model of quantum computation. In fact, even a hybrid computation containing both qubit and CV quantum nodes is possible;</p> <p>We will only see the qubit model with the <code>'default.qubit', 'lightning.qubit', 'lightning.gpu'</code> device provided by PennyLane.</p>"},{"location":"pennylane_presentation/#qnode","title":"QNode\u00b6","text":"<p>Now that we have initialized our device, we can begin to construct a quantum node (or QNode).</p>"},{"location":"pennylane_presentation/#definition","title":"Definition\u00b6","text":"<p>QNodes are an abstract encapsulation of a quantum function, described by a quantum circuit. QNodes are bound to a particular quantum device, which is used to evaluate expectation and variance values of this circuit.</p> <p>QNodes can be constructed via the QNode class, or by using the provided qnode decorator.</p> <p>First, we need to define the quantum function that will be evaluated in the QNode:</p>"},{"location":"pennylane_presentation/#quantum-circuits-examples","title":"Quantum circuits examples\u00b6","text":"<p>Let's setup our device as follow:</p>"},{"location":"pennylane_presentation/#pauli-gates-x-y-z","title":"PAULI GATES X, Y, Z\u00b6","text":"<p>The Pauli gates are single-qubit gates that perform rotations about the respective axes of the Bloch sphere.</p> <p>The Bloch sphere is a geometric representation of the pure state of a qubit on a unit sphere in three-dimensional space and is used to visualize and describe the quantum state of the qubit. Quantum gates and operations on a qubit can be visualized as rotations of the state vector on the Bloch sphere.</p>"},{"location":"pennylane_presentation/#hadamard-gate","title":"Hadamard gate\u00b6","text":"<p>The Hadamard gate creates a superposition state from a computational basis state.</p>"},{"location":"pennylane_presentation/#controlled-not-gate-cnot","title":"Controlled-NOT Gate (CNOT)\u00b6","text":"<p>The Controlled-NOT (CNOT) gate is a two-qubit gate that flips the state of the second qubit (target) if the first qubit (control) is in the \u22231\u27e9 state.</p>"},{"location":"pennylane_presentation/#rotation-gates-rx-ry-rz","title":"Rotation gates RX, RY, RZ\u00b6","text":"<p>Rotation gates rotate the state of a qubit around a specific axis of the Bloch sphere by a given angle.</p>"},{"location":"pennylane_presentation/#swap-gate","title":"Swap gate\u00b6","text":"<p>The SWAP gate swaps the states of two qubits.</p>"},{"location":"pennylane_presentation/#implement-a-2-qubit-quantum-fourier-transform","title":"Implement a 2-qubit Quantum Fourier Transform.\u00b6","text":""},{"location":"pennylane_presentation/#basic-tutorial-qubit-rotation","title":"Basic tutorial: qubit rotation\u00b6","text":"<p>To see how PennyLane allows the easy construction and optimization of quantum functions, let's consider the simple case of qubit rotation the PennyLane version of the 'Hello, world!' example.</p> <p>The task at hand is to optimize two rotation gates in order to flip a single qubit from state $\\left|0\\right\\rangle$ to state $\\left|1\\right\\rangle$.</p>"},{"location":"pennylane_presentation/#the-quantum-circuit","title":"The quantum circuit\u00b6","text":"<p>In the qubit rotation example, we wish to implement the following quantum circuit:</p> <p>Breaking this down step-by-step, we first start with a qubit in the ground state $|0\\rangle = \\begin{bmatrix}1 &amp; 0 \\end{bmatrix}^T$, and rotate it around the x-axis by applying the gate</p> <p>$$\\begin{aligned} R_x(\\phi_1) = e^{-i \\phi_1 \\sigma_x /2} = \\begin{bmatrix} \\cos \\frac{\\phi_1}{2} &amp;  -i \\sin \\frac{\\phi_1}{2} \\\\ -i \\sin \\frac{\\phi_1}{2} &amp;  \\cos \\frac{\\phi_1}{2} \\end{bmatrix}, \\end{aligned}$$</p> <p>and then around the y-axis via the gate</p> <p>$$\\begin{aligned} R_y(\\phi_2) = e^{-i \\phi_2 \\sigma_y/2} = \\begin{bmatrix} \\cos \\frac{\\phi_2}{2} &amp;  - \\sin \\frac{\\phi_2}{2} \\\\ \\sin \\frac{\\phi_2}{2} &amp;  \\cos \\frac{\\phi_2}{2} \\end{bmatrix}. \\end{aligned}$$</p> <p>After these operations the qubit is now in the state</p> <p>$$| \\psi \\rangle = R_y(\\phi_2) R_x(\\phi_1) | 0 \\rangle.$$</p> <p>Finally, we measure the expectation value $\\langle \\psi \\mid \\sigma_z \\mid \\psi \\rangle$ of the Pauli-Z operator</p> <p>$$\\begin{aligned} \\sigma_z = \\begin{bmatrix} 1 &amp;  0 \\\\ 0 &amp; -1 \\end{bmatrix}. \\end{aligned}$$</p> <p>Using the above to calculate the exact expectation value, we find that</p> <p>$$\\langle \\psi \\mid \\sigma_z \\mid \\psi \\rangle = \\langle 0 \\mid R_x(\\phi_1)^\\dagger R_y(\\phi_2)^\\dagger \\sigma_z  R_y(\\phi_2) R_x(\\phi_1) \\mid 0 \\rangle = \\cos(\\phi_1)\\cos(\\phi_2).$$</p> <p>Depending on the circuit parameters $\\phi_1$ and $\\phi_2$, the output expectation lies between $1$ (if $\\left|\\psi\\right\\rangle = \\left|0\\right\\rangle$) and $-1$ (if $\\left|\\psi\\right\\rangle = \\left|1\\right\\rangle$).</p>"},{"location":"pennylane_presentation/#calculating-quantum-gradients","title":"Calculating quantum gradients\u00b6","text":"<p>The gradient of the function <code>circuit</code>, encapsulated within the <code>QNode</code>, can be evaluated by utilizing the same quantum device (<code>dev</code>) that we used to evaluate the function itself.</p> <p>PennyLane incorporates both analytic differentiation, as well as numerical methods (such as the method of finite differences). Both of these are done automatically.</p> <p>We can differentiate by using the <code>jax</code> function. This returns another function, representing the gradient (i.e., the vector of partial derivatives) of <code>circuit</code>. The gradient can be evaluated in the same way as the original function:</p>"},{"location":"pennylane_presentation/#optimization","title":"Optimization\u00b6","text":""},{"location":"pennylane_presentation/#definition","title":"Definition\u00b6","text":"<p>If using the default NumPy/Autograd interface, PennyLane provides a collection of optimizers based on gradient descent. These optimizers accept a cost function and initial parameters, and utilize PennyLane's automatic differentiation to perform gradient descent.</p> <p>Next, let's make use of PennyLane's built-in optimizers to optimize the two circuit parameters $\\phi_1$ and $\\phi_2$ such that the qubit, originally in state $\\left|0\\right\\rangle$, is rotated to be in state $\\left|1\\right\\rangle$. This is equivalent to reasuring a Pauli-Z expectation value of $-1$, since the state $\\left|1\\right\\rangle$ is an eigenvector of the Pauli-Z matrix with eigenvalue $\\lambda=-1$.</p> <p>In other words, the optimization procedure will find the weights $\\phi_1$ and $\\phi_2$ that result in the following rotation on the Bloch sphere:</p> <p>To do so, we need to define a cost function. By minimizing the cost function, the optimizer will determine the values of the circuit parameters that produce the desired outcome.</p> <p>In this case, our desired outcome is a Pauli-Z expectation value of $-1$. Since we know that the Pauli-Z expectation is bound between $[-1, 1]$, we can define our cost directly as the output of the QNode:</p>"},{"location":"pennylane_presentation/#quantum-teleportation","title":"Quantum Teleportation\u00b6","text":"<p>This section walks through a popular quantum information technique known as quantum teleportation. While teleportation has been thought of as the stuff of sci-fi legend, we are going to prove that it is actually already possible today! The technique leverages many foundational principles of quantum computing, and it has lots of useful applications across the entire field. These principles include (but are not limited to): the no-cloning theorem, quantum entanglement, and the principle of deferred measurement. Let\u2019s dive in!</p>"},{"location":"pennylane_presentation/#goal-transferring-quantum-information","title":"Goal: Transferring Quantum Information\u00b6","text":"<p>Suppose there are two researchers named Alice and Bob, and Alice wants to send her quantum state to Bob. The quantum teleportation protocol enables Alice to do exactly this in a very elegant manner, and it can be described in four steps:</p> <p>1. State preparation: Alice initializes her qubit to the state she wishes to teleport.</p> <p>2. Shared entanglement: A Bell state is created and distributed to Alice and Bob (one qubit each).</p> <p>3. Change of basis: Alice converts her two qubits from the Bell basis to the computational basis.</p> <p>4. Measurement: Alice measures her two qubits, then tells Bob how to convert his qubit to obtain the desired state. Note that it is only quantum information being teleported, and not a physical particle.</p> <p>An overview of the protocol can be seen here:</p>"},{"location":"pennylane_presentation/#problem-the-no-cloning-theorem","title":"Problem: The No-Cloning Theorem\u00b6","text":"<p>You might be wondering why we need to teleport a state at all. Can't Alice just make a copy of it and send the copy to Bob? It turns out that copying arbitrary states is prohibited, which you can understand using something called the no-cloning theorem. The proof is surprisingly straightforward. Suppose we would like to design a circuit (unitary transformation) $U$ that can perform the following action:</p> <p>$$\\begin{aligned} \\begin{align*} U(\\vert \\psi\\rangle \\otimes \\vert s\\rangle ) &amp;= \\vert \\psi\\rangle \\otimes \\vert \\psi\\rangle, \\\\ U(\\vert \\varphi\\rangle \\otimes \\vert s\\rangle ) &amp;= \\vert \\varphi \\rangle \\otimes \\vert \\varphi \\rangle, \\end{align*} \\end{aligned}$$</p> <p>where $\\vert \\psi\\rangle$ and $\\vert \\varphi\\rangle$ are arbitrary, normalized single-qubit states, and $\\vert s \\rangle$ is some arbitrary, normalized starting state. We will now prove that no such $U$ exists!</p> <p>First, let's take the inner product of the left-hand sides of the two equations:</p> <p>$$(\\langle \\psi \\vert \\otimes \\langle s \\vert) U^\\dagger U(\\vert \\varphi\\rangle \\otimes \\vert s\\rangle ) = \\langle \\psi \\vert \\varphi\\rangle \\  \\langle s \\vert s\\rangle$$</p> <p>Since $\\langle s \\vert s\\rangle$ equals 1, this evaluates to $\\langle \\psi \\vert \\varphi \\rangle$. Next, we compare the inner product of the right-hand sides of the two equations: $(\\langle \\psi \\vert \\varphi \\rangle)^2$. These inner products must be equal, and they are only equal if they are a value that squares to itself. The only valid values for the inner product then are 1 and 0. But if the inner product is 1, the states are the same; on the other hand, if the inner product is 0, the states are orthogonal. Therefore, we can't clone arbitrary states!</p>"},{"location":"pennylane_presentation/#solution-quantum-teleportation","title":"Solution: Quantum Teleportation\u00b6","text":"<p>We will now walk through how to share quantum information without cloning it, one step at a time.</p>"},{"location":"pennylane_presentation/#i-state-preparation","title":"I. State preparation\u00b6","text":"<p>Teleportation involves three qubits. Two of them are held by Alice, and the third by Bob. We'll denote their states using subscripts:</p> <ol> <li>$\\vert\\cdot\\rangle_S$, Alice's first qubit that she will prepare in some arbitrary state</li> <li>$\\vert\\cdot\\rangle_A$, Alice's auxiliary (or \"ancilla\") qubit that she will entangle with Bob's qubit for communication purposes</li> <li>$\\vert \\cdot\\rangle_B$, Bob's qubit that will receive the teleported state</li> </ol> <p>Together, their starting state is:</p> <p>$$\\vert 0\\rangle_S \\vert 0\\rangle_A \\vert 0\\rangle_B.$$</p> <p>The first thing Alice does is prepare her first qubit in whichever state $\\vert \\psi\\rangle$ that she'd like to send to Bob so that their combined state becomes:</p> <p>$$\\vert \\psi\\rangle_S \\vert 0\\rangle_A \\vert 0\\rangle_B.$$</p> <p>We can use the following quantum function to do the state preparation step:</p>"},{"location":"pennylane_presentation/#ii-shared-entanglement","title":"II. Shared entanglement\u00b6","text":"<p>The reason why teleportation works is the use of an entangled state as a shared resource between Alice and Bob. You can imagine some process that generates a pair of entangled qubits, and sends one qubit to each party. For simplicity (and simulation!), we will represent the entanglement process as part of our circuit.</p> <p>Entangling the qubits $A$ and $B$ leads to the combined state:</p> <p>$$\\frac{1}{\\sqrt{2}}\\left( \\vert \\psi\\rangle_S \\vert 0\\rangle_A \\vert 0\\rangle_B + \\vert \\psi\\rangle_S \\vert 1\\rangle_A \\vert 1\\rangle_B \\right)\\tag{1}$$</p> <p>The $AB$ subsystem is now in what is known as a Bell state. There are four maximally entangled two-qubit Bell states, and they form the Bell basis:</p> <p>$$\\begin{aligned} \\begin{align*} \\vert \\psi_+\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 00\\rangle + \\vert 11\\rangle \\right), \\\\ \\vert \\psi_-\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 00\\rangle - \\vert 11\\rangle \\right), \\\\ \\vert \\phi_+\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 01\\rangle + \\vert 10\\rangle \\right), \\\\ \\vert \\phi_-\\rangle &amp;= \\frac{1}{\\sqrt{2}} \\left( \\vert 01\\rangle - \\vert 10\\rangle \\right). \\end{align*} \\end{aligned}$$</p> <p>In our experiment, because $AB$ started in the $\\vert 00\\rangle$ state, we create the $\\vert \\psi_+\\rangle$ Bell state as is shown in equation (1).</p>"},{"location":"pennylane_presentation/#iii-change-of-basis","title":"III. Change of basis\u00b6","text":"<p>This is where things get tricky, but also very interesting. The third step of the protocol is to apply a CNOT and a Hadamard to the first two qubits. This is done prior to the measurements, and labelled \"change of basis\". But what basis is this? Notice how these two gates are the opposite of what we do to create a Bell state. If we run them in the opposite direction, we transform the basis back to the computational one, and simulate a measurement in the Bell basis.</p> <p>After the basis transform, if we observe the first two qubits to be in the state $\\vert 00\\rangle$, this would correspond to the outcome $\\vert \\psi_+\\rangle$ in the Bell basis, $\\vert 11\\rangle$ would correspond to $\\vert \\phi_-\\rangle$, etc. Let's perform this change of basis, one step at a time.</p> <p>Suppose we write our initial state $\\vert \\psi\\rangle$ as $\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle$, with $\\alpha$ and $\\beta$ being complex coefficients. Expanding out the terms from (1), we obtain:</p> <p>$$\\frac{1}{\\sqrt{2}} ( \\alpha\\vert 000\\rangle + \\beta\\vert 100\\rangle + \\alpha \\vert 011\\rangle + \\beta\\vert 111\\rangle )$$</p> <p>Now let's apply a CNOT between Alice's two qubits:</p> <p>$$\\frac{1}{\\sqrt{2}} ( \\alpha\\vert 000\\rangle + \\beta\\vert 110\\rangle + \\alpha \\vert 011\\rangle + \\beta\\vert 101\\rangle )$$</p> <p>And then a Hadamard on her first qubit:</p> <p>$$\\frac{1}{2} ( \\alpha \\vert 000\\rangle + \\alpha\\vert 100\\rangle + \\beta\\vert 010\\rangle - \\beta\\vert 110\\rangle + \\alpha \\vert 011\\rangle + \\alpha \\vert 111 \\rangle + \\beta\\vert 001\\rangle - \\beta\\vert 101 \\rangle ).$$</p> <p>Now we need to do some rearranging. We group the terms based on the first two qubits:</p> <p>$$\\frac{1}{2} \\vert 00\\rangle(\\alpha\\vert 0\\rangle + \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 01\\rangle (\\beta\\vert 0\\rangle + \\alpha\\vert 1\\rangle) + \\frac{1}{2}\\vert 10\\rangle (\\alpha\\vert 0\\rangle - \\beta\\vert 1\\rangle) + \\frac{1}{2}\\vert 11\\rangle (-\\beta\\vert 0\\rangle + \\alpha\\vert 1\\rangle).\\tag{2}$$</p>"},{"location":"pennylane_presentation/#iv-measurement","title":"IV. Measurement\u00b6","text":"<p>The last step of the protocol involves Alice performing a measurement on her qubits, and telling Bob to perform some operations depending on what she measured. But why exactly do we need to do this? In the previous step, we already performed a basis rotation back to the computational basis, so shouldn't we be good to go? Not quite, but almost!</p> <p>Let's take another look at equation (2). If Alice measures her two qubits in the computational basis, she is equally likely to obtain any of the four possible outcomes. If she observes the first two qubits in the state $\\vert 00 \\rangle$, she would immediately know that Bob's qubit was in the state $\\alpha \\vert 0 \\rangle + \\beta \\vert 1 \\rangle$, which is precisely the state we are trying to teleport!</p> <p>If instead she observed the qubits in state $\\vert 01\\rangle$, she'd still know what state Bob has, but it's a little off from the original state. In particular, we have:</p> <p>$$\\beta \\vert 0 \\rangle + \\alpha \\vert 1 \\rangle = X \\vert \\psi \\rangle.$$</p> <p>After obtaining these results, Alice could tell Bob to simply apply an X gate to his qubit to recover the original state. Similarly, if she obtained $\\vert 10\\rangle$, she would tell him to apply a Z gate.</p> <p>In the \"traditional\" version of quantum teleportation, this is, in fact, exactly what happens. Alice would call up Bob on the phone, tell him which state she observed, and then he would be able to apply an appropriate correction. In this situation, measurements are happening partway through the protocol, and the results would be used to control the application of future quantum gates. This is known as mid-circuit measurement, and such mid-circuit measurements are expressed in PennyLane using <code>qml.measure &lt;pennylane.measure&gt;</code>{.interpreted-text role=\"func\"}. Mid-circuit measurement results can be used to control operations, and this is expressed in PennyLane using <code>qml.cond &lt;pennylane.cond&gt;</code>{.interpreted-text role=\"func\"}.</p>"},{"location":"pennylane_presentation/#conclusion","title":"Conclusion\u00b6","text":"<p>Let's recap the concepts we've just seen. First, we established that quantum states cannot be arbitrarily copied due to the no-cloning theorem. Then, we learned about quantum entanglement. Once Alice and Bob shared an entangled pair of qubits, Alice performed a change of basis from the Bell basis to the computational basis. Finally, using the principle of deferred measurement when needed, Alice measured her two qubits and informed Bob on how to rotate his qubit into the desired state.</p> <p>Just like that, Alice and Bob performed quantum teleportation, and with a fairly small circuit! Some of you may now be thinking that teleportation is impossible, and you would be in good company if so. Einstein himself referred to the non-local nature of entanglement as \"spooky action at a distance\", but we can all rest easy: due to the need for classical communication from Alice to Bob, quantum states (in other words, information) still cannot be teleported faster than the speed of light. Don't let that take away from the importance of quantum teleportation! This protocol is a critical tool in quantum information processing, and now it is a tool that you wield.</p>"},{"location":"pennylane_presentation/#quantum-simulations-using-lightninggpu-with-nvidia-cuquantum-sdk","title":"Quantum simulations using <code>lightning.gpu</code> with NVIDIA cuQuantum SDK\u00b6","text":"<p>PennyLane supports GPU simulation through the <code>lightning.gpu</code> simulator device, which offloads quantum gate calls to the NVIDIA cuQuantum SDK.</p>"},{"location":"pennylane_presentation/#benefits","title":"Benefits\u00b6","text":"<p>GPUs are highly effective for workloads that massively depend on linear algebra due to their greater floating-point processing capabilities. In classical machine learning, especially deep learning, GPUs significantly accelerate training compared to CPUs. While GPUs generally have less on-device memory than CPU nodes, they offer high memory bandwidth and support a large number of concurrent threads. This makes them particularly well-suited for memory-bound operations like vector-vector products and vector scaling.</p> <p>Additionally, GPUs have optimized implementations of fundamental mathematical operations which make them a perfect match in compute-bound tasks such as dense matrix-matrix multiplications. Since quantum mechanics is frequently expressed using linear algebra and complex numbers, these GPU strengths can be harnessed to efficiently simulate quantum circuits.</p>"},{"location":"pennylane_presentation/#the-lightning-gpu-simulator-device","title":"The <code>lightning-gpu</code> simulator device\u00b6","text":"<p><code>lightning.gpu</code> offloads quantum gate calls to <code>Nvidia's cuQuantum cuStateVec</code> library kernels and functions, extending the work from <code>lightning.qubit</code> to capture and manipulate the Numpy data buffer in-place for direct support of machine-learning frameworks like TensorFlow, PyTorch, and JAX. The state-vector memory buffer is copied from NumPy to the GPU device, where all GPU-implemented functions are called to perform the required manipulations. Unsupported gate kernels are CPU-generated, transferred to the GPU, and cached for later reuse. Expectation values are evaluated directly on the GPU, and the state-vector is returned to a NumPy-compatible array on the host machine for easy manipulation by the end-user.</p>"},{"location":"pennylane_presentation/#meluxina-gpu-module","title":"MeluXina GPU module\u00b6","text":"<p>We have 200 nodes on MeluXina GPU featuring 2 AMD Rome CPUs (32 cores @ 2.35 GHz - 128HT cores total) and 4 NVIDIA A100-40 GPUs per node.</p> <p>The A100 GPU based on the Ampere GPU, offers significant improvements in performance and efficiency for both AI training and inference tasks. While not specifically designed for quantum computing simulations, the A100's massive parallel processing capabilities and high memory bandwidth make it well-suited for certain quantum computing tasks, particularly those involving tensor network calculations or quantum circuit simulations.</p>"},{"location":"pennylane_presentation/#benchmark","title":"Benchmark\u00b6","text":"<p>As a demonstration, we take a simple quantum circuit Jacobian evaluation and compare the run-times for lightning.qubit and lightning.gpu, using adjoint backpropagation for both cases, but allowing the lightning.qubit threading support to take full advantage of the available CPU. The circuit below evaluates the Jacobian of a strongly entangling layered circuit, and was run on an NVIDIA A100, comparing an A100 40GB GPU to an AMD Epyc 7H12 CPU:</p>"},{"location":"pennylane_presentation/#distributing-quantum-simulations-using-lightninggpu-with-nvidia-cuquantum","title":"Distributing quantum simulations using <code>lightning.gpu</code> with NVIDIA cuQuantum\u00b6","text":"<p>PennyLane supports distributed state vector simulations with the <code>lightning.gpu</code> simulator device , which offloads quantum gate calls to cuStateVec, and other distributed operations to Message Passing Interface (MPI).</p> <p>By adding a few addtional arguments when constructing a <code>lightning.gpu</code> device, a distributed simulation can be lauched and optimized easily, leading to better performance.</p>"},{"location":"pennylane_presentation/#background","title":"Background\u00b6","text":"<p>Simulating quantum systems is highly resource-intensive. State-vector simulation remains the preferred method for many quantum circuit workloads. However, a major limitation is the exponential growth in memory requirements as the number of qubits increases. On a desktop computer, simulations typically max out at around 30 qubits, and adding just a few more can exceed the memory capacity of a single high-performance computing (HPC) node. Memory management is even more crucial when using graphics processing units (GPUs). To leverage the performance advantages of GPUs, it's beneficial to use multiple GPUs in tandem to store and operate on a single state vector.</p> <p>Simulating quantum systems requires storing the state vector, which grows exponentially with the number of qubits <code>n</code>. Each additional qubit doubles the size of the state vector, leading to significant memory demands. In double-precision calculations, storing the state vector of an $n-qubit$ system requires $2^n \\times 2^4$ bytes of memory. This exponential growth quickly exceeds the memory capacity of single GPUs, which typically max out at 80 GB. For instance, simulating a 32-qubit system requires about 68.7 GB of memory just for the state vector. To simulate systems larger than 32 qubits, it's necessary to distribute the state vector across multiple GPUs working in tandem, as a single GPU cannot handle the memory requirements alone.</p>"},{"location":"pennylane_presentation/#pennylane-gpumpi-support","title":"PennyLane GPU/MPI support\u00b6","text":"<p>Enabling distributed state vector simulation support is straightforward: just include the <code>mpi=True</code> argument when creating a <code>lightning.gpu</code> device:</p>"},{"location":"pennylane_presentation/#benchmark","title":"Benchmark\u00b6","text":"<p>To demonstrate larger systems can be simulated with lightning.gpu with MPI support, and as a multi-node extension of the example above, we first take a sample quantum circuit Jacobian evaluation of a strongly entangling layered (SEL) circuit using adjoint differentiation. The script will run on four-GPU nodes. Each GPU node has 4 NVIDIA A100 40GB Tensor Core GPUs.</p>"},{"location":"pennylane_presentation/#conclusion","title":"Conclusion\u00b6","text":"<p>With MPI support, <code>lightning.gpu</code> enables large-scale quantum workloads using multiple nodes and GPUs, making previously intractable simulations feasible. Benchmark tests demonstrate that systems with over 30 qubits can be simulated through distributed computing, with performance improving as more GPUs are employed. By integrating full feature parity into its MPI backend, simulations that once ran on a single GPU can now be easily extended to multi-node and multi-GPU setups by adding a few additional arguments when configuring the <code>lightning.gpu</code> device.</p>"}]}